namespace Sylvester

open FSharp.Quotations
open FSharp.Quotations.Patterns
open FSharp.Quotations.DerivedPatterns

open Patterns
open Descriptions

/// Theory of algebraic operations on a ring of integers with binary operations (+) and (*), identities 0 and 1, 
/// and unary inverse operation (-).
module IntegerAlgebra =      
    /// Print Unicode logical operator symbols
    let print_integer_algebra_operators (s:string) = 
        s.Replace("*", "\u22C5")
    let desc = axiom_desc "Integer Algebra" print_integer_algebra_operators
    
    (* Axioms *)
    let integer_algebra_axioms =
        function                    
        | Assoc <@(=)@> <@ (+) @> x
        | Assoc <@(=)@> <@ (*) @> x
        | Identity <@(=)@> <@ (+) @> <@ 0 @> x 
        | Identity <@(=)@> <@ (*) @> <@ 1 @> x
        | Inverse <@(=)@> <@ (+) @> <@ (~-) @> <@ 0 @> x
        | Commute <@(=)@> <@ (+) @> x
        | Commute <@(=)@> <@ (*) @> x
        | Distrib <@(=)@> <@ (*) @> <@ (+) @> x 
        | LeftCancel <@ (*) @> x 
        | LeftCancel <@ (+) @> x
        | BinaryOpDefR <@(=)@> <@ (-) @> <@ (+) @> <@ (~-) @> x -> Some (desc x) 
        | _ -> None
                    
    let rec reduce_constants  =
        function
        | Add(Int32 l, Int32 r) -> Expr.Value(l + r)
        | Subtract(Int32 l, Int32 r) -> Expr.Value(l - r)        
        | Multiply(Int32 l, Int32 r) -> Expr.Value(l * r)

        | expr -> traverse expr reduce_constants
    
    let rec right_assoc =
        function
        | Add(Add(a1, a2), a3) -> <@@ %%a1 + (%%a2 + %%a3) @@>
        | Subtract(Subtract(a1, a2), a3) -> <@@ %%a1 - (%%a2 + %%a3) @@>
        | Multiply(Multiply(a1, a2), a3) -> <@@ %%a1 * (%%a2 * %%a3) @@>
        | expr -> traverse expr right_assoc

    let rec left_assoc =
        function
        | Add(a1, Add(a2, a3)) -> <@@ (%%a1 + %%a2) + %%a3 @@>
        | Subtract(a1, Subtract(a2, a3)) -> <@@ (%%a1 - %%a2) + %%a3 @@>
        | Multiply(a1, Multiply(a2, a3)) -> <@@ (%%a1 * %%a2) * %%a3 @@>
        | expr -> traverse expr left_assoc

    let rec commute =
        function
        | Add(a1, a2) -> <@@ (%%a2 + %%a1) @@>
        | Multiply(a1, a2) -> <@@ (%%a2 * %%a1) @@>
        | expr -> traverse expr commute

    let rec distrib =
        function
        | Multiply(a1, Add(a2, a3)) -> <@@ %%a1 * %%a2 + %%a1 * %%a3 @@> 
        | Multiply(a1, Subtract(a2, a3)) -> <@@ %%a1 * %%a2 - %%a1 * %%a3 @@> 
        | expr -> traverse expr distrib

    let rec collect =
        function
        | Add(Multiply(a1, a2), Multiply(a3, a4)) when sequal a1 a3 -> <@@ %%a1 * (%%a2 + %%a4) @@>
        | Add(Multiply(a1, a2), Multiply(a3, a4)) when sequal a2 a4 -> <@@ %%a2 * (%%a1 + %%a3) @@>
        
        | Subtract(Multiply(a1, a2), Multiply(a3, a4)) when sequal a1 a3 -> <@@ %%a1 * (%%a2 - %%a4) @@>
        | Subtract(Multiply(a1, a2), Multiply(a3, a4)) when sequal a2 a4 -> <@@ %%a2 * (%%a1 - %%a3) @@>
        | expr -> traverse expr collect

    let rec left_cancel =
        function
        | NewTuple(Add(a1, a2)::Add(a3, a4)::[]) when sequal a1 a3 -> <@@ (%%a2:int) = (%%a4:int) @@>
        | NewTuple(Multiply(a1, a2)::Multiply(a3, a4)::[]) when sequal a1 a3 -> <@@ (%%a2:int) = (%%a4:int) @@>
        | NewTuple(Subtract(a1, a2)::Subtract(a3, a4)::[]) when sequal a1 a3 -> <@@ (%%a2:int) = (%%a4:int) @@>
        | expr -> traverse expr left_cancel

    /// Reduce equal constants in expression. 
    let Reduce = Admit("Reduce integer constants in (expression)", reduce_constants)

    /// Expression is left associative.
    let LeftAssoc = Admit("(expression) is left-associative", left_assoc)
    
    /// Expression is right associative.
    let RightAssoc = Admit("(expression) is right-associative", right_assoc)
      
    /// Expression is commutative.
    let Commute = Admit("(expression) is commutative", commute)

    /// Multiplication distributes over addition in expression.
    let Distrib = Admit("Multiplication distributes over addition in (expression)", distrib)
    
    /// Collect multiplication terms distributed over addition in expression.
    let Collect = Admit("Collect multiplication terms distributed over addition in (expression)", collect)
    
    /// Cancel equivalent terms on the LHS in expression.
    let LeftCancel = Admit("Cancel equivalent terms on the LHS in (expression)", left_cancel)

    /// Theory of algebraic operations on a ring of integers with binary operations (+) and (*), identities 0 and 1, 
    /// and unary inverse operation (~-).
    let integer_algebra = Theory(integer_algebra_axioms, [
            Reduce 
            LeftAssoc 
            RightAssoc 
            Commute 
            Distrib
            Collect
            LeftCancel
    ], print_integer_algebra_operators)

    (* proof step shortcuts*)
    let int_id_ax expr = id_ax integer_algebra expr 
    let int_id expr = ident integer_algebra expr

    let ident_add p = ident integer_algebra <@ (%p + 0) = %p @> [
        L Commute
        LR RightAssoc
    ]
	
	namespace Sylvester

open System
open FSharp.Quotations
open FSharp.Quotations.Patterns
open FSharp.Quotations.DerivedPatterns

open Patterns
open Descriptions

/// Theory of algebraic operations on an integral domain of integers with binary operations (+) and (*) and (*) distributes over (+), 
/// identities 0 and 1, and unary inverse operation (-), where c <> 0  ==> (c * a = c * b = (a = b)).
module IntegerAlgebra =      
    (* Symbols *)
    do Symbols.BulitIn.Add(src <@ (*) @>, "\u22C5")
    
    let desc = axiom_desc "Integer Algebra"
    
    (* Axioms *)
    let integer_algebra_axioms =
        function                    
        | Assoc <@(=)@> <@ (+) @> x
        | Assoc <@(=)@> <@ (*) @> x
        | Commute <@(=)@> <@ (+) @> x
        | Commute <@(=)@> <@ (*) @> x
        | Identity <@(=)@> <@ (+) @> <@ 0 @> x 
        | Identity <@(=)@> <@ (*) @> <@ 1 @> x
        | Inverse <@(=)@> <@ (+) @> <@ (~-) @> <@ 0 @> x
        | Distrib <@(=)@> <@ (*) @> <@ (+) @> x  
        | LeftCancelNonZero <@ (+) @> <@ 0 @> x
        | BinaryOpDefR <@(=)@> <@ (-) @> <@ (+) @> <@ (~-) @> x  -> Some (desc x)
        | Exists(_, a::[], Bool true, (Equals(Add(Var _, Var a'), Int32 0))) when vequal a a' -> Some (axiom_desc "Integer Algebra" (pattern_desc' "Additive inverse")) 
        | _ -> None

    let rec _reduce_constants  =
        function
        | Add(UInt16 l, UInt16 r) -> <@@ l + r @@>  
        | Add(UInt32 l, UInt32 r) -> <@@ l + r @@>
        | Add(UInt64 l, UInt64 r) -> <@@ l + r @@>
        | Add(Int16 l, Int16 r) -> <@@ l + r @@>  
        | Add(Int32 l, Int32 r) -> <@@ l + r @@>
        | Add(Int64 l, Int64 r) -> <@@ l + r @@>
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>  
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>
        | Add(Double l, Double r) -> <@@ l + r @@>  
        | Add(Double l, Double r) -> <@@ l + r @@>
        | Add(Double l, Double r) -> <@@ l + r @@>
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>  
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>
        | Add(Decimal l, Decimal r) -> <@@ l + r @@>

        | Multiply(UInt16 l, UInt16 r) -> <@@ l * r @@>  
        | Multiply(UInt32 l, UInt32 r) -> <@@ l * r @@>
        | Multiply(UInt64 l, UInt64 r) -> <@@ l * r @@>
        | Multiply(Int16 l, Int16 r) -> <@@ l * r @@>  
        | Multiply(Int32 l, Int32 r) -> <@@ l * r @@>
        | Multiply(Int64 l, Int64 r) -> <@@ l * r @@>
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>  
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>
        | Multiply(Double l, Double r) -> <@@ l * r @@>  
        | Multiply(Double l, Double r) -> <@@ l * r @@>
        | Multiply(Double l, Double r) -> <@@ l * r @@>
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>  
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>
        | Multiply(Decimal l, Decimal r) -> <@@ l * r @@>

        | Subtract(UInt16 l, UInt16 r) -> <@@ l - r @@>  
        | Subtract(UInt32 l, UInt32 r) -> <@@ l - r @@>
        | Subtract(UInt64 l, UInt64 r) -> <@@ l - r @@>
        | Subtract(Int16 l, Int16 r) -> <@@ l - r @@>  
        | Subtract(Int32 l, Int32 r) -> <@@ l - r @@>
        | Subtract(Int64 l, Int64 r) -> <@@ l - r @@>
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>  
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>
        | Subtract(Double l, Double r) -> <@@ l - r @@>  
        | Subtract(Double l, Double r) -> <@@ l - r @@>
        | Subtract(Double l, Double r) -> <@@ l - r @@>
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>  
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>
        | Subtract(Decimal l, Decimal r) -> <@@ l - r @@>

        | expr -> traverse expr _reduce_constants

    let rec _right_assoc =
        function
        | Add(Add(a1, a2), a3) -> call_add a1 (call_add a2 a3)
        | Multiply(Multiply(a1, a2), a3) -> call_mul a1 (call_add a2 a3)
        | expr -> traverse expr _right_assoc

    let rec _left_assoc =
        function
        | Add(a1, Add(a2, a3)) -> call_add (call_add a1 a2) a3
        | Multiply(a1, Multiply(a2, a3)) -> call_mul (call_mul a1 a2) a3
        | expr -> traverse expr _left_assoc

    let rec _commute =
        function
        | Add(a1, a2) -> call_add a2 a1
        | Multiply(a1, a2) -> call_mul a2 a1
        | expr -> traverse expr _commute

    let rec _distrib =
        function
        | Multiply(a1, Add(a2, a3)) -> call_add (call_mul a1 a2)  (call_mul a1 a3) 
        | Multiply(a1, Subtract(a2, a3)) -> call_sub (call_mul a1 a2) (call_mul a1 a3) 
        | expr -> traverse expr _distrib

    let rec _collect =
        function
        | Add(Multiply(a1, a2), Multiply(a1', a3)) when sequal a1 a1' -> call_mul a1 (call_add a2 a3) 
        | Subtract(Multiply(a1, a2), Multiply(a1', a3)) when sequal a1 a1' -> call_mul a1 (call_sub a2 a3) 
        | expr -> traverse expr _collect

    let rec _ident =
        function
        | Add(x, UInt16 0us) -> x
        | Add(x, Int16 0s) -> x
        | Add(x, UInt32 0u) -> x
        | Add(x, Int32 0) -> x
        | Add(x, UInt64 0UL) -> x
        | Add(x, Int64 0L) -> x
        | Add(x, Single 0.0f) -> x
        | Add(x, Double 0.) -> x
        | Add(x, Decimal 0m) -> x

        | Multiply(x, UInt16 1us) -> x
        | Multiply(x, Int16 1s) -> x
        | Multiply(x, UInt32 1u) -> x
        | Multiply(x, Int32 1) -> x
        | Multiply(x, UInt64 1UL) -> x
        | Multiply(x, Int64 1L) -> x
        | Multiply(x, Single 1.1f) -> x
        | Multiply(x, Double 1.) -> x
        | Multiply(x, Decimal 1m) -> x

        | expr -> traverse expr _ident