// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/rewriter_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/rewriter_config.proto</summary>
  public static partial class RewriterConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/rewriter_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RewriterConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci50ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvcmV3cml0ZXJfY29uZmlnLnBy",
            "b3RvEgp0ZW5zb3JmbG93Gip0ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL2F0",
            "dHJfdmFsdWUucHJvdG8iOwoTQXV0b1BhcmFsbGVsT3B0aW9ucxIOCgZlbmFi",
            "bGUYASABKAgSFAoMbnVtX3JlcGxpY2FzGAIgASgFIisKFlNjb3BlZEFsbG9j",
            "YXRvck9wdGlvbnMSEQoJZW5hYmxlX29wGAEgAygJIvUNCg5SZXdyaXRlckNv",
            "bmZpZxI7ChBsYXlvdXRfb3B0aW1pemVyGAEgASgOMiEudGVuc29yZmxvdy5S",
            "ZXdyaXRlckNvbmZpZy5Ub2dnbGUSOwoQY29uc3RhbnRfZm9sZGluZxgDIAEo",
            "DjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xlEj0KEnNoYXBl",
            "X29wdGltaXphdGlvbhgNIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25m",
            "aWcuVG9nZ2xlEjQKCXJlbWFwcGluZxgOIAEoDjIhLnRlbnNvcmZsb3cuUmV3",
            "cml0ZXJDb25maWcuVG9nZ2xlEkIKF2FyaXRobWV0aWNfb3B0aW1pemF0aW9u",
            "GAcgASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSQgoX",
            "ZGVwZW5kZW5jeV9vcHRpbWl6YXRpb24YCCABKA4yIS50ZW5zb3JmbG93LlJl",
            "d3JpdGVyQ29uZmlnLlRvZ2dsZRI8ChFsb29wX29wdGltaXphdGlvbhgJIAEo",
            "DjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkAKFWZ1bmN0",
            "aW9uX29wdGltaXphdGlvbhgKIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJD",
            "b25maWcuVG9nZ2xlEjkKDmRlYnVnX3N0cmlwcGVyGAsgASgOMiEudGVuc29y",
            "Zmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSHQoVZGlzYWJsZV9tb2RlbF9w",
            "cnVuaW5nGAIgASgIEkgKHXNjb3BlZF9hbGxvY2F0b3Jfb3B0aW1pemF0aW9u",
            "GA8gASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSQwoY",
            "cGluX3RvX2hvc3Rfb3B0aW1pemF0aW9uGBIgASgOMiEudGVuc29yZmxvdy5S",
            "ZXdyaXRlckNvbmZpZy5Ub2dnbGUSHgoWZGlzYWJsZV9tZXRhX29wdGltaXpl",
            "chgTIAEoCBJPChltZXRhX29wdGltaXplcl9pdGVyYXRpb25zGAwgASgOMiwu",
            "dGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5OdW1JdGVyYXRpb25zVHlwZRIX",
            "Cg9taW5fZ3JhcGhfbm9kZXMYESABKAUSQgoTbWVtb3J5X29wdGltaXphdGlv",
            "bhgEIAEoDjIlLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuTWVtT3B0VHlw",
            "ZRIvCidtZW1vcnlfb3B0aW1pemVyX3RhcmdldF9ub2RlX25hbWVfc2NvcGUY",
            "BiABKAkSIQoZbWV0YV9vcHRpbWl6ZXJfdGltZW91dF9tcxgUIAEoAxI2Cg1h",
            "dXRvX3BhcmFsbGVsGAUgASgLMh8udGVuc29yZmxvdy5BdXRvUGFyYWxsZWxP",
            "cHRpb25zEiAKGGZhaWxfb25fb3B0aW1pemVyX2Vycm9ycxgVIAEoCBJBChVz",
            "Y29wZWRfYWxsb2NhdG9yX29wdHMYECABKAsyIi50ZW5zb3JmbG93LlNjb3Bl",
            "ZEFsbG9jYXRvck9wdGlvbnMSEgoKb3B0aW1pemVycxhkIAMoCRJLChFjdXN0",
            "b21fb3B0aW1pemVycxjIASADKAsyLy50ZW5zb3JmbG93LlJld3JpdGVyQ29u",
            "ZmlnLkN1c3RvbUdyYXBoT3B0aW1pemVyGsoBChRDdXN0b21HcmFwaE9wdGlt",
            "aXplchIMCgRuYW1lGAEgASgJElgKDXBhcmFtZXRlcl9tYXAYAiADKAsyQS50",
            "ZW5zb3JmbG93LlJld3JpdGVyQ29uZmlnLkN1c3RvbUdyYXBoT3B0aW1pemVy",
            "LlBhcmFtZXRlck1hcEVudHJ5GkoKEVBhcmFtZXRlck1hcEVudHJ5EgsKA2tl",
            "eRgBIAEoCRIkCgV2YWx1ZRgCIAEoCzIVLnRlbnNvcmZsb3cuQXR0clZhbHVl",
            "OgI4ASI2CgZUb2dnbGUSCwoHREVGQVVMVBAAEgYKAk9OEAESBwoDT0ZGEAIS",
            "DgoKQUdHUkVTU0lWRRADIjwKEU51bUl0ZXJhdGlvbnNUeXBlEhUKEURFRkFV",
            "TFRfTlVNX0lURVJTEAASBwoDT05FEAESBwoDVFdPEAIinwEKCk1lbU9wdFR5",
            "cGUSEwoPREVGQVVMVF9NRU1fT1BUEAASDgoKTk9fTUVNX09QVBABEgoKBk1B",
            "TlVBTBACEhcKE1NXQVBQSU5HX0hFVVJJU1RJQ1MQBBIcChhSRUNPTVBVVEFU",
            "SU9OX0hFVVJJU1RJQ1MQBRIZChVTQ0hFRFVMSU5HX0hFVVJJU1RJQ1MQBhIO",
            "CgpIRVVSSVNUSUNTEANCcwoYb3JnLnRlbnNvcmZsb3cuZnJhbWV3b3JrQhRS",
            "ZXdyaXRlckNvbmZpZ1Byb3Rvc1ABWjxnaXRodWIuY29tL3RlbnNvcmZsb3cv",
            "dGVuc29yZmxvdy90ZW5zb3JmbG93L2dvL2NvcmUvcHJvdG9idWb4AQFiBnBy",
            "b3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.AttrValueReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.AutoParallelOptions), global::Tensorflow.AutoParallelOptions.Parser, new[]{ "Enable", "NumReplicas" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.ScopedAllocatorOptions), global::Tensorflow.ScopedAllocatorOptions.Parser, new[]{ "EnableOp" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig), global::Tensorflow.RewriterConfig.Parser, new[]{ "LayoutOptimizer", "ConstantFolding", "ShapeOptimization", "Remapping", "ArithmeticOptimization", "DependencyOptimization", "LoopOptimization", "FunctionOptimization", "DebugStripper", "DisableModelPruning", "ScopedAllocatorOptimization", "PinToHostOptimization", "DisableMetaOptimizer", "MetaOptimizerIterations", "MinGraphNodes", "MemoryOptimization", "MemoryOptimizerTargetNodeNameScope", "MetaOptimizerTimeoutMs", "AutoParallel", "FailOnOptimizerErrors", "ScopedAllocatorOpts", "Optimizers", "CustomOptimizers" }, null, new[]{ typeof(global::Tensorflow.RewriterConfig.Types.Toggle), typeof(global::Tensorflow.RewriterConfig.Types.NumIterationsType), typeof(global::Tensorflow.RewriterConfig.Types.MemOptType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer), global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer.Parser, new[]{ "Name", "ParameterMap" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class AutoParallelOptions : pb::IMessage<AutoParallelOptions> {
    private static readonly pb::MessageParser<AutoParallelOptions> _parser = new pb::MessageParser<AutoParallelOptions>(() => new AutoParallelOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoParallelOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions(AutoParallelOptions other) : this() {
      enable_ = other.enable_;
      numReplicas_ = other.numReplicas_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions Clone() {
      return new AutoParallelOptions(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 2;
    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoParallelOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoParallelOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      if (NumReplicas != other.NumReplicas) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (NumReplicas != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumReplicas);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoParallelOptions other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
          case 16: {
            NumReplicas = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ScopedAllocatorOptions : pb::IMessage<ScopedAllocatorOptions> {
    private static readonly pb::MessageParser<ScopedAllocatorOptions> _parser = new pb::MessageParser<ScopedAllocatorOptions>(() => new ScopedAllocatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedAllocatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions(ScopedAllocatorOptions other) : this() {
      enableOp_ = other.enableOp_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions Clone() {
      return new ScopedAllocatorOptions(this);
    }

    /// <summary>Field number for the "enable_op" field.</summary>
    public const int EnableOpFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_enableOp_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> enableOp_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If present, only perform optimization for these ops.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EnableOp {
      get { return enableOp_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedAllocatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedAllocatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!enableOp_.Equals(other.enableOp_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= enableOp_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      enableOp_.WriteTo(output, _repeated_enableOp_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += enableOp_.CalculateSize(_repeated_enableOp_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedAllocatorOptions other) {
      if (other == null) {
        return;
      }
      enableOp_.Add(other.enableOp_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            enableOp_.AddEntriesFrom(input, _repeated_enableOp_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Graph rewriting is experimental and subject to change, not covered by any
  /// API stability guarantees.
  /// </summary>
  public sealed partial class RewriterConfig : pb::IMessage<RewriterConfig> {
    private static readonly pb::MessageParser<RewriterConfig> _parser = new pb::MessageParser<RewriterConfig>(() => new RewriterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RewriterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig(RewriterConfig other) : this() {
      layoutOptimizer_ = other.layoutOptimizer_;
      constantFolding_ = other.constantFolding_;
      shapeOptimization_ = other.shapeOptimization_;
      remapping_ = other.remapping_;
      arithmeticOptimization_ = other.arithmeticOptimization_;
      dependencyOptimization_ = other.dependencyOptimization_;
      loopOptimization_ = other.loopOptimization_;
      functionOptimization_ = other.functionOptimization_;
      debugStripper_ = other.debugStripper_;
      disableModelPruning_ = other.disableModelPruning_;
      scopedAllocatorOptimization_ = other.scopedAllocatorOptimization_;
      pinToHostOptimization_ = other.pinToHostOptimization_;
      disableMetaOptimizer_ = other.disableMetaOptimizer_;
      metaOptimizerIterations_ = other.metaOptimizerIterations_;
      minGraphNodes_ = other.minGraphNodes_;
      memoryOptimization_ = other.memoryOptimization_;
      memoryOptimizerTargetNodeNameScope_ = other.memoryOptimizerTargetNodeNameScope_;
      metaOptimizerTimeoutMs_ = other.metaOptimizerTimeoutMs_;
      autoParallel_ = other.autoParallel_ != null ? other.autoParallel_.Clone() : null;
      failOnOptimizerErrors_ = other.failOnOptimizerErrors_;
      scopedAllocatorOpts_ = other.scopedAllocatorOpts_ != null ? other.scopedAllocatorOpts_.Clone() : null;
      optimizers_ = other.optimizers_.Clone();
      customOptimizers_ = other.customOptimizers_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig Clone() {
      return new RewriterConfig(this);
    }

    /// <summary>Field number for the "layout_optimizer" field.</summary>
    public const int LayoutOptimizerFieldNumber = 1;
    private global::Tensorflow.RewriterConfig.Types.Toggle layoutOptimizer_ = 0;
    /// <summary>
    /// Optimize tensor layouts (default is ON)
    /// e.g. This will try to use NCHW layout on GPU which is faster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle LayoutOptimizer {
      get { return layoutOptimizer_; }
      set {
        layoutOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "constant_folding" field.</summary>
    public const int ConstantFoldingFieldNumber = 3;
    private global::Tensorflow.RewriterConfig.Types.Toggle constantFolding_ = 0;
    /// <summary>
    /// Fold constants (default is ON)
    /// Statically infer the value of tensors when possible, and materialize the
    /// result using constants.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ConstantFolding {
      get { return constantFolding_; }
      set {
        constantFolding_ = value;
      }
    }

    /// <summary>Field number for the "shape_optimization" field.</summary>
    public const int ShapeOptimizationFieldNumber = 13;
    private global::Tensorflow.RewriterConfig.Types.Toggle shapeOptimization_ = 0;
    /// <summary>
    /// Shape optimizations (default is ON)
    /// Simplify computations made on shapes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ShapeOptimization {
      get { return shapeOptimization_; }
      set {
        shapeOptimization_ = value;
      }
    }

    /// <summary>Field number for the "remapping" field.</summary>
    public const int RemappingFieldNumber = 14;
    private global::Tensorflow.RewriterConfig.Types.Toggle remapping_ = 0;
    /// <summary>
    /// Remapping (default is ON)
    /// Remap subgraphs onto more efficient implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle Remapping {
      get { return remapping_; }
      set {
        remapping_ = value;
      }
    }

    /// <summary>Field number for the "arithmetic_optimization" field.</summary>
    public const int ArithmeticOptimizationFieldNumber = 7;
    private global::Tensorflow.RewriterConfig.Types.Toggle arithmeticOptimization_ = 0;
    /// <summary>
    /// Arithmetic optimizations (default is ON)
    /// e.g. Simplify arithmetic ops; merge ops with same value (like constants).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ArithmeticOptimization {
      get { return arithmeticOptimization_; }
      set {
        arithmeticOptimization_ = value;
      }
    }

    /// <summary>Field number for the "dependency_optimization" field.</summary>
    public const int DependencyOptimizationFieldNumber = 8;
    private global::Tensorflow.RewriterConfig.Types.Toggle dependencyOptimization_ = 0;
    /// <summary>
    /// Control dependency optimizations (default is ON).
    /// Remove redundant control dependencies, which may enable other optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle DependencyOptimization {
      get { return dependencyOptimization_; }
      set {
        dependencyOptimization_ = value;
      }
    }

    /// <summary>Field number for the "loop_optimization" field.</summary>
    public const int LoopOptimizationFieldNumber = 9;
    private global::Tensorflow.RewriterConfig.Types.Toggle loopOptimization_ = 0;
    /// <summary>
    /// Loop optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle LoopOptimization {
      get { return loopOptimization_; }
      set {
        loopOptimization_ = value;
      }
    }

    /// <summary>Field number for the "function_optimization" field.</summary>
    public const int FunctionOptimizationFieldNumber = 10;
    private global::Tensorflow.RewriterConfig.Types.Toggle functionOptimization_ = 0;
    /// <summary>
    /// Function optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle FunctionOptimization {
      get { return functionOptimization_; }
      set {
        functionOptimization_ = value;
      }
    }

    /// <summary>Field number for the "debug_stripper" field.</summary>
    public const int DebugStripperFieldNumber = 11;
    private global::Tensorflow.RewriterConfig.Types.Toggle debugStripper_ = 0;
    /// <summary>
    /// Strips debug-related nodes from the graph (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle DebugStripper {
      get { return debugStripper_; }
      set {
        debugStripper_ = value;
      }
    }

    /// <summary>Field number for the "disable_model_pruning" field.</summary>
    public const int DisableModelPruningFieldNumber = 2;
    private bool disableModelPruning_;
    /// <summary>
    /// If true, don't remove unnecessary ops from the graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableModelPruning {
      get { return disableModelPruning_; }
      set {
        disableModelPruning_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_optimization" field.</summary>
    public const int ScopedAllocatorOptimizationFieldNumber = 15;
    private global::Tensorflow.RewriterConfig.Types.Toggle scopedAllocatorOptimization_ = 0;
    /// <summary>
    /// Try to allocate some independent Op outputs contiguously in order to
    /// merge or eliminate downstream Ops (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ScopedAllocatorOptimization {
      get { return scopedAllocatorOptimization_; }
      set {
        scopedAllocatorOptimization_ = value;
      }
    }

    /// <summary>Field number for the "pin_to_host_optimization" field.</summary>
    public const int PinToHostOptimizationFieldNumber = 18;
    private global::Tensorflow.RewriterConfig.Types.Toggle pinToHostOptimization_ = 0;
    /// <summary>
    /// Force small ops onto the CPU (default is OFF).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle PinToHostOptimization {
      get { return pinToHostOptimization_; }
      set {
        pinToHostOptimization_ = value;
      }
    }

    /// <summary>Field number for the "disable_meta_optimizer" field.</summary>
    public const int DisableMetaOptimizerFieldNumber = 19;
    private bool disableMetaOptimizer_;
    /// <summary>
    /// Disable the entire meta optimizer (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableMetaOptimizer {
      get { return disableMetaOptimizer_; }
      set {
        disableMetaOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "meta_optimizer_iterations" field.</summary>
    public const int MetaOptimizerIterationsFieldNumber = 12;
    private global::Tensorflow.RewriterConfig.Types.NumIterationsType metaOptimizerIterations_ = 0;
    /// <summary>
    /// Controls how many times we run the optimizers in meta optimizer (default
    /// is once).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.NumIterationsType MetaOptimizerIterations {
      get { return metaOptimizerIterations_; }
      set {
        metaOptimizerIterations_ = value;
      }
    }

    /// <summary>Field number for the "min_graph_nodes" field.</summary>
    public const int MinGraphNodesFieldNumber = 17;
    private int minGraphNodes_;
    /// <summary>
    /// The minimum number of nodes in a graph to optimizer. For smaller graphs,
    /// optimization is skipped.
    /// 0 means the system picks an appropriate number.
    /// &lt; 0 means do not skip optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinGraphNodes {
      get { return minGraphNodes_; }
      set {
        minGraphNodes_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimization" field.</summary>
    public const int MemoryOptimizationFieldNumber = 4;
    private global::Tensorflow.RewriterConfig.Types.MemOptType memoryOptimization_ = 0;
    /// <summary>
    /// Configures memory optimization passes through the meta-optimizer. Has no
    /// effect on manually requested memory optimization passes in the optimizers
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.MemOptType MemoryOptimization {
      get { return memoryOptimization_; }
      set {
        memoryOptimization_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimizer_target_node_name_scope" field.</summary>
    public const int MemoryOptimizerTargetNodeNameScopeFieldNumber = 6;
    private string memoryOptimizerTargetNodeNameScope_ = "";
    /// <summary>
    /// A node name scope for node names which are valid outputs of recompuations.
    /// Inputs to nodes that match this scope may be recomputed (subject either to
    /// manual annotation of those input nodes or to manual annotation and
    /// heuristics depending on memory_optimization), but the nodes themselves will
    /// not be recomputed. This matches any sub-scopes as well, meaning the scope
    /// can appear not just as a top-level scope. For example, if the value is
    /// "gradients/", the default, it will match node name "gradients/foo",
    /// "foo/gradients/bar", but not "foo_gradients/"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MemoryOptimizerTargetNodeNameScope {
      get { return memoryOptimizerTargetNodeNameScope_; }
      set {
        memoryOptimizerTargetNodeNameScope_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meta_optimizer_timeout_ms" field.</summary>
    public const int MetaOptimizerTimeoutMsFieldNumber = 20;
    private long metaOptimizerTimeoutMs_;
    /// <summary>
    /// Maximum number of milliseconds to spend optimizing a single graph before
    /// timing out. If equal to 0 the system picks a default (currently 5 minutes).
    /// If less than 0 the optimizer will never time out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MetaOptimizerTimeoutMs {
      get { return metaOptimizerTimeoutMs_; }
      set {
        metaOptimizerTimeoutMs_ = value;
      }
    }

    /// <summary>Field number for the "auto_parallel" field.</summary>
    public const int AutoParallelFieldNumber = 5;
    private global::Tensorflow.AutoParallelOptions autoParallel_;
    /// <summary>
    /// Configures AutoParallel optimization passes either through the
    /// meta-optimizer or when manually specified through the optimizers field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.AutoParallelOptions AutoParallel {
      get { return autoParallel_; }
      set {
        autoParallel_ = value;
      }
    }

    /// <summary>Field number for the "fail_on_optimizer_errors" field.</summary>
    public const int FailOnOptimizerErrorsFieldNumber = 21;
    private bool failOnOptimizerErrors_;
    /// <summary>
    /// If true, any optimization pass failing will cause the MetaOptimizer to
    /// stop with an error. By default - or when set to false, failing passes are
    /// skipped silently.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FailOnOptimizerErrors {
      get { return failOnOptimizerErrors_; }
      set {
        failOnOptimizerErrors_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_opts" field.</summary>
    public const int ScopedAllocatorOptsFieldNumber = 16;
    private global::Tensorflow.ScopedAllocatorOptions scopedAllocatorOpts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.ScopedAllocatorOptions ScopedAllocatorOpts {
      get { return scopedAllocatorOpts_; }
      set {
        scopedAllocatorOpts_ = value;
      }
    }

    /// <summary>Field number for the "optimizers" field.</summary>
    public const int OptimizersFieldNumber = 100;
    private static readonly pb::FieldCodec<string> _repeated_optimizers_codec
        = pb::FieldCodec.ForString(802);
    private readonly pbc::RepeatedField<string> optimizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If non-empty, will use this as an alternative way to specify a list of
    /// optimizations to turn on and the order of the optimizations (replacing the
    /// meta-optimizer).
    ///
    /// Of the RewriterConfig options, only the AutoParallel configuration options
    /// (the auto_parallel field) apply to manually requested optimization passes
    /// ("autoparallel"). Memory optimization passes ("memory") invoked here are
    /// not configurable (in contrast to memory optimization passes through the
    /// meta-optimizer) and act only on manual op annotations.
    ///
    /// Custom optimizers (see custom_optimizers) that are not part of this
    /// schedule will be run after - in the order that they were specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Optimizers {
      get { return optimizers_; }
    }

    /// <summary>Field number for the "custom_optimizers" field.</summary>
    public const int CustomOptimizersFieldNumber = 200;
    private static readonly pb::FieldCodec<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> _repeated_customOptimizers_codec
        = pb::FieldCodec.ForMessage(1602, global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> customOptimizers_ = new pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer>();
    /// <summary>
    /// list of CustomGraphOptimizers to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> CustomOptimizers {
      get { return customOptimizers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RewriterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RewriterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LayoutOptimizer != other.LayoutOptimizer) return false;
      if (ConstantFolding != other.ConstantFolding) return false;
      if (ShapeOptimization != other.ShapeOptimization) return false;
      if (Remapping != other.Remapping) return false;
      if (ArithmeticOptimization != other.ArithmeticOptimization) return false;
      if (DependencyOptimization != other.DependencyOptimization) return false;
      if (LoopOptimization != other.LoopOptimization) return false;
      if (FunctionOptimization != other.FunctionOptimization) return false;
      if (DebugStripper != other.DebugStripper) return false;
      if (DisableModelPruning != other.DisableModelPruning) return false;
      if (ScopedAllocatorOptimization != other.ScopedAllocatorOptimization) return false;
      if (PinToHostOptimization != other.PinToHostOptimization) return false;
      if (DisableMetaOptimizer != other.DisableMetaOptimizer) return false;
      if (MetaOptimizerIterations != other.MetaOptimizerIterations) return false;
      if (MinGraphNodes != other.MinGraphNodes) return false;
      if (MemoryOptimization != other.MemoryOptimization) return false;
      if (MemoryOptimizerTargetNodeNameScope != other.MemoryOptimizerTargetNodeNameScope) return false;
      if (MetaOptimizerTimeoutMs != other.MetaOptimizerTimeoutMs) return false;
      if (!object.Equals(AutoParallel, other.AutoParallel)) return false;
      if (FailOnOptimizerErrors != other.FailOnOptimizerErrors) return false;
      if (!object.Equals(ScopedAllocatorOpts, other.ScopedAllocatorOpts)) return false;
      if(!optimizers_.Equals(other.optimizers_)) return false;
      if(!customOptimizers_.Equals(other.customOptimizers_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LayoutOptimizer != 0) hash ^= LayoutOptimizer.GetHashCode();
      if (ConstantFolding != 0) hash ^= ConstantFolding.GetHashCode();
      if (ShapeOptimization != 0) hash ^= ShapeOptimization.GetHashCode();
      if (Remapping != 0) hash ^= Remapping.GetHashCode();
      if (ArithmeticOptimization != 0) hash ^= ArithmeticOptimization.GetHashCode();
      if (DependencyOptimization != 0) hash ^= DependencyOptimization.GetHashCode();
      if (LoopOptimization != 0) hash ^= LoopOptimization.GetHashCode();
      if (FunctionOptimization != 0) hash ^= FunctionOptimization.GetHashCode();
      if (DebugStripper != 0) hash ^= DebugStripper.GetHashCode();
      if (DisableModelPruning != false) hash ^= DisableModelPruning.GetHashCode();
      if (ScopedAllocatorOptimization != 0) hash ^= ScopedAllocatorOptimization.GetHashCode();
      if (PinToHostOptimization != 0) hash ^= PinToHostOptimization.GetHashCode();
      if (DisableMetaOptimizer != false) hash ^= DisableMetaOptimizer.GetHashCode();
      if (MetaOptimizerIterations != 0) hash ^= MetaOptimizerIterations.GetHashCode();
      if (MinGraphNodes != 0) hash ^= MinGraphNodes.GetHashCode();
      if (MemoryOptimization != 0) hash ^= MemoryOptimization.GetHashCode();
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) hash ^= MemoryOptimizerTargetNodeNameScope.GetHashCode();
      if (MetaOptimizerTimeoutMs != 0L) hash ^= MetaOptimizerTimeoutMs.GetHashCode();
      if (autoParallel_ != null) hash ^= AutoParallel.GetHashCode();
      if (FailOnOptimizerErrors != false) hash ^= FailOnOptimizerErrors.GetHashCode();
      if (scopedAllocatorOpts_ != null) hash ^= ScopedAllocatorOpts.GetHashCode();
      hash ^= optimizers_.GetHashCode();
      hash ^= customOptimizers_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LayoutOptimizer != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LayoutOptimizer);
      }
      if (DisableModelPruning != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableModelPruning);
      }
      if (ConstantFolding != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ConstantFolding);
      }
      if (MemoryOptimization != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoParallel);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(MemoryOptimizerTargetNodeNameScope);
      }
      if (ArithmeticOptimization != 0) {
        output.WriteRawTag(56);
        output.WriteEnum((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DependencyOptimization);
      }
      if (LoopOptimization != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) LoopOptimization);
      }
      if (FunctionOptimization != 0) {
        output.WriteRawTag(80);
        output.WriteEnum((int) FunctionOptimization);
      }
      if (DebugStripper != 0) {
        output.WriteRawTag(88);
        output.WriteEnum((int) DebugStripper);
      }
      if (MetaOptimizerIterations != 0) {
        output.WriteRawTag(96);
        output.WriteEnum((int) MetaOptimizerIterations);
      }
      if (ShapeOptimization != 0) {
        output.WriteRawTag(104);
        output.WriteEnum((int) ShapeOptimization);
      }
      if (Remapping != 0) {
        output.WriteRawTag(112);
        output.WriteEnum((int) Remapping);
      }
      if (ScopedAllocatorOptimization != 0) {
        output.WriteRawTag(120);
        output.WriteEnum((int) ScopedAllocatorOptimization);
      }
      if (scopedAllocatorOpts_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ScopedAllocatorOpts);
      }
      if (MinGraphNodes != 0) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(MinGraphNodes);
      }
      if (PinToHostOptimization != 0) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) PinToHostOptimization);
      }
      if (DisableMetaOptimizer != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(DisableMetaOptimizer);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        output.WriteRawTag(160, 1);
        output.WriteInt64(MetaOptimizerTimeoutMs);
      }
      if (FailOnOptimizerErrors != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(FailOnOptimizerErrors);
      }
      optimizers_.WriteTo(output, _repeated_optimizers_codec);
      customOptimizers_.WriteTo(output, _repeated_customOptimizers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LayoutOptimizer != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LayoutOptimizer);
      }
      if (ConstantFolding != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConstantFolding);
      }
      if (ShapeOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ShapeOptimization);
      }
      if (Remapping != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Remapping);
      }
      if (ArithmeticOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DependencyOptimization);
      }
      if (LoopOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LoopOptimization);
      }
      if (FunctionOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FunctionOptimization);
      }
      if (DebugStripper != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DebugStripper);
      }
      if (DisableModelPruning != false) {
        size += 1 + 1;
      }
      if (ScopedAllocatorOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScopedAllocatorOptimization);
      }
      if (PinToHostOptimization != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PinToHostOptimization);
      }
      if (DisableMetaOptimizer != false) {
        size += 2 + 1;
      }
      if (MetaOptimizerIterations != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MetaOptimizerIterations);
      }
      if (MinGraphNodes != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MinGraphNodes);
      }
      if (MemoryOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MemoryOptimization);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MemoryOptimizerTargetNodeNameScope);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(MetaOptimizerTimeoutMs);
      }
      if (autoParallel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoParallel);
      }
      if (FailOnOptimizerErrors != false) {
        size += 2 + 1;
      }
      if (scopedAllocatorOpts_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScopedAllocatorOpts);
      }
      size += optimizers_.CalculateSize(_repeated_optimizers_codec);
      size += customOptimizers_.CalculateSize(_repeated_customOptimizers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RewriterConfig other) {
      if (other == null) {
        return;
      }
      if (other.LayoutOptimizer != 0) {
        LayoutOptimizer = other.LayoutOptimizer;
      }
      if (other.ConstantFolding != 0) {
        ConstantFolding = other.ConstantFolding;
      }
      if (other.ShapeOptimization != 0) {
        ShapeOptimization = other.ShapeOptimization;
      }
      if (other.Remapping != 0) {
        Remapping = other.Remapping;
      }
      if (other.ArithmeticOptimization != 0) {
        ArithmeticOptimization = other.ArithmeticOptimization;
      }
      if (other.DependencyOptimization != 0) {
        DependencyOptimization = other.DependencyOptimization;
      }
      if (other.LoopOptimization != 0) {
        LoopOptimization = other.LoopOptimization;
      }
      if (other.FunctionOptimization != 0) {
        FunctionOptimization = other.FunctionOptimization;
      }
      if (other.DebugStripper != 0) {
        DebugStripper = other.DebugStripper;
      }
      if (other.DisableModelPruning != false) {
        DisableModelPruning = other.DisableModelPruning;
      }
      if (other.ScopedAllocatorOptimization != 0) {
        ScopedAllocatorOptimization = other.ScopedAllocatorOptimization;
      }
      if (other.PinToHostOptimization != 0) {
        PinToHostOptimization = other.PinToHostOptimization;
      }
      if (other.DisableMetaOptimizer != false) {
        DisableMetaOptimizer = other.DisableMetaOptimizer;
      }
      if (other.MetaOptimizerIterations != 0) {
        MetaOptimizerIterations = other.MetaOptimizerIterations;
      }
      if (other.MinGraphNodes != 0) {
        MinGraphNodes = other.MinGraphNodes;
      }
      if (other.MemoryOptimization != 0) {
        MemoryOptimization = other.MemoryOptimization;
      }
      if (other.MemoryOptimizerTargetNodeNameScope.Length != 0) {
        MemoryOptimizerTargetNodeNameScope = other.MemoryOptimizerTargetNodeNameScope;
      }
      if (other.MetaOptimizerTimeoutMs != 0L) {
        MetaOptimizerTimeoutMs = other.MetaOptimizerTimeoutMs;
      }
      if (other.autoParallel_ != null) {
        if (autoParallel_ == null) {
          autoParallel_ = new global::Tensorflow.AutoParallelOptions();
        }
        AutoParallel.MergeFrom(other.AutoParallel);
      }
      if (other.FailOnOptimizerErrors != false) {
        FailOnOptimizerErrors = other.FailOnOptimizerErrors;
      }
      if (other.scopedAllocatorOpts_ != null) {
        if (scopedAllocatorOpts_ == null) {
          scopedAllocatorOpts_ = new global::Tensorflow.ScopedAllocatorOptions();
        }
        ScopedAllocatorOpts.MergeFrom(other.ScopedAllocatorOpts);
      }
      optimizers_.Add(other.optimizers_);
      customOptimizers_.Add(other.customOptimizers_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            layoutOptimizer_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 16: {
            DisableModelPruning = input.ReadBool();
            break;
          }
          case 24: {
            constantFolding_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 32: {
            memoryOptimization_ = (global::Tensorflow.RewriterConfig.Types.MemOptType) input.ReadEnum();
            break;
          }
          case 42: {
            if (autoParallel_ == null) {
              autoParallel_ = new global::Tensorflow.AutoParallelOptions();
            }
            input.ReadMessage(autoParallel_);
            break;
          }
          case 50: {
            MemoryOptimizerTargetNodeNameScope = input.ReadString();
            break;
          }
          case 56: {
            arithmeticOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 64: {
            dependencyOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 72: {
            loopOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 80: {
            functionOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 88: {
            debugStripper_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 96: {
            metaOptimizerIterations_ = (global::Tensorflow.RewriterConfig.Types.NumIterationsType) input.ReadEnum();
            break;
          }
          case 104: {
            shapeOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 112: {
            remapping_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 120: {
            scopedAllocatorOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 130: {
            if (scopedAllocatorOpts_ == null) {
              scopedAllocatorOpts_ = new global::Tensorflow.ScopedAllocatorOptions();
            }
            input.ReadMessage(scopedAllocatorOpts_);
            break;
          }
          case 136: {
            MinGraphNodes = input.ReadInt32();
            break;
          }
          case 144: {
            pinToHostOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 152: {
            DisableMetaOptimizer = input.ReadBool();
            break;
          }
          case 160: {
            MetaOptimizerTimeoutMs = input.ReadInt64();
            break;
          }
          case 168: {
            FailOnOptimizerErrors = input.ReadBool();
            break;
          }
          case 802: {
            optimizers_.AddEntriesFrom(input, _repeated_optimizers_codec);
            break;
          }
          case 1602: {
            customOptimizers_.AddEntriesFrom(input, _repeated_customOptimizers_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RewriterConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Toggle {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("ON")] On = 1,
        [pbr::OriginalName("OFF")] Off = 2,
        /// <summary>
        /// Enable some aggressive optimizations that use assumptions that TF graphs
        /// may break. For example, assume the shape of a placeholder matches its
        /// actual feed.
        /// </summary>
        [pbr::OriginalName("AGGRESSIVE")] Aggressive = 3,
      }

      /// <summary>
      /// Enum controlling the number of times to run optimizers. The default is to
      /// run them twice.
      /// </summary>
      public enum NumIterationsType {
        [pbr::OriginalName("DEFAULT_NUM_ITERS")] DefaultNumIters = 0,
        [pbr::OriginalName("ONE")] One = 1,
        [pbr::OriginalName("TWO")] Two = 2,
      }

      public enum MemOptType {
        /// <summary>
        /// The default setting (SCHEDULING and SWAPPING HEURISTICS only)
        /// </summary>
        [pbr::OriginalName("DEFAULT_MEM_OPT")] DefaultMemOpt = 0,
        /// <summary>
        /// Disabled in the meta-optimizer.
        /// </summary>
        [pbr::OriginalName("NO_MEM_OPT")] NoMemOpt = 1,
        /// <summary>
        /// Driven by manual op-level annotations.
        /// </summary>
        [pbr::OriginalName("MANUAL")] Manual = 2,
        /// <summary>
        /// Swapping heuristic will move a tensor from the GPU to the CPU and move
        /// it back when needed to reduce peak memory usage.
        /// </summary>
        [pbr::OriginalName("SWAPPING_HEURISTICS")] SwappingHeuristics = 4,
        /// <summary>
        /// Recomputation heuristics will recompute ops (such as Relu activation)
        /// during backprop instead of storing them, reducing peak memory usage.
        /// </summary>
        [pbr::OriginalName("RECOMPUTATION_HEURISTICS")] RecomputationHeuristics = 5,
        /// <summary>
        /// Scheduling will split big ops such as AddN and try to enforce a schedule
        /// of the new computations that decreases peak memory usage.
        /// </summary>
        [pbr::OriginalName("SCHEDULING_HEURISTICS")] SchedulingHeuristics = 6,
        /// <summary>
        /// Use any combination of swapping and recomputation heuristics.
        /// </summary>
        [pbr::OriginalName("HEURISTICS")] Heuristics = 3,
      }

      /// <summary>
      /// Message to describe custom graph optimizer and its parameters
      /// </summary>
      public sealed partial class CustomGraphOptimizer : pb::IMessage<CustomGraphOptimizer> {
        private static readonly pb::MessageParser<CustomGraphOptimizer> _parser = new pb::MessageParser<CustomGraphOptimizer>(() => new CustomGraphOptimizer());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CustomGraphOptimizer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.RewriterConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer(CustomGraphOptimizer other) : this() {
          name_ = other.name_;
          parameterMap_ = other.parameterMap_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer Clone() {
          return new CustomGraphOptimizer(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "parameter_map" field.</summary>
        public const int ParameterMapFieldNumber = 2;
        private static readonly pbc::MapField<string, global::Tensorflow.AttrValue>.Codec _map_parameterMap_codec
            = new pbc::MapField<string, global::Tensorflow.AttrValue>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Tensorflow.AttrValue.Parser), 18);
        private readonly pbc::MapField<string, global::Tensorflow.AttrValue> parameterMap_ = new pbc::MapField<string, global::Tensorflow.AttrValue>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Tensorflow.AttrValue> ParameterMap {
          get { return parameterMap_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CustomGraphOptimizer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CustomGraphOptimizer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!ParameterMap.Equals(other.ParameterMap)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= ParameterMap.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          parameterMap_.WriteTo(output, _map_parameterMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += parameterMap_.CalculateSize(_map_parameterMap_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CustomGraphOptimizer other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          parameterMap_.Add(other.parameterMap_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                parameterMap_.AddEntriesFrom(input, _map_parameterMap_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
