// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/meta_graph.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/meta_graph.proto</summary>
  public static partial class MetaGraphReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/meta_graph.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MetaGraphReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cil0ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvbWV0YV9ncmFwaC5wcm90bxIK",
            "dGVuc29yZmxvdxoZZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90bxoldGVuc29y",
            "Zmxvdy9jb3JlL2ZyYW1ld29yay9ncmFwaC5wcm90bxomdGVuc29yZmxvdy9j",
            "b3JlL2ZyYW1ld29yay9vcF9kZWYucHJvdG8aLHRlbnNvcmZsb3cvY29yZS9m",
            "cmFtZXdvcmsvdGVuc29yX3NoYXBlLnByb3RvGiV0ZW5zb3JmbG93L2NvcmUv",
            "ZnJhbWV3b3JrL3R5cGVzLnByb3RvGiR0ZW5zb3JmbG93L2NvcmUvcHJvdG9i",
            "dWYvc2F2ZXIucHJvdG8i4wUKDE1ldGFHcmFwaERlZhI7Cg1tZXRhX2luZm9f",
            "ZGVmGAEgASgLMiQudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuTWV0YUluZm9E",
            "ZWYSJwoJZ3JhcGhfZGVmGAIgASgLMhQudGVuc29yZmxvdy5HcmFwaERlZhIn",
            "CglzYXZlcl9kZWYYAyABKAsyFC50ZW5zb3JmbG93LlNhdmVyRGVmEkMKDmNv",
            "bGxlY3Rpb25fZGVmGAQgAygLMisudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYu",
            "Q29sbGVjdGlvbkRlZkVudHJ5EkEKDXNpZ25hdHVyZV9kZWYYBSADKAsyKi50",
            "ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5TaWduYXR1cmVEZWZFbnRyeRIwCg5h",
            "c3NldF9maWxlX2RlZhgGIAMoCzIYLnRlbnNvcmZsb3cuQXNzZXRGaWxlRGVm",
            "GukBCgtNZXRhSW5mb0RlZhIaChJtZXRhX2dyYXBoX3ZlcnNpb24YASABKAkS",
            "LAoQc3RyaXBwZWRfb3BfbGlzdBgCIAEoCzISLnRlbnNvcmZsb3cuT3BMaXN0",
            "EiYKCGFueV9pbmZvGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRIMCgR0",
            "YWdzGAQgAygJEhoKEnRlbnNvcmZsb3dfdmVyc2lvbhgFIAEoCRIeChZ0ZW5z",
            "b3JmbG93X2dpdF92ZXJzaW9uGAYgASgJEh4KFnN0cmlwcGVkX2RlZmF1bHRf",
            "YXR0cnMYByABKAgaTwoSQ29sbGVjdGlvbkRlZkVudHJ5EgsKA2tleRgBIAEo",
            "CRIoCgV2YWx1ZRgCIAEoCzIZLnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZjoC",
            "OAEaTQoRU2lnbmF0dXJlRGVmRW50cnkSCwoDa2V5GAEgASgJEicKBXZhbHVl",
            "GAIgASgLMhgudGVuc29yZmxvdy5TaWduYXR1cmVEZWY6AjgBIt8DCg1Db2xs",
            "ZWN0aW9uRGVmEjcKCW5vZGVfbGlzdBgBIAEoCzIiLnRlbnNvcmZsb3cuQ29s",
            "bGVjdGlvbkRlZi5Ob2RlTGlzdEgAEjkKCmJ5dGVzX2xpc3QYAiABKAsyIy50",
            "ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQnl0ZXNMaXN0SAASOQoKaW50NjRf",
            "bGlzdBgDIAEoCzIjLnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5JbnQ2NExp",
            "c3RIABI5CgpmbG9hdF9saXN0GAQgASgLMiMudGVuc29yZmxvdy5Db2xsZWN0",
            "aW9uRGVmLkZsb2F0TGlzdEgAEjUKCGFueV9saXN0GAUgASgLMiEudGVuc29y",
            "Zmxvdy5Db2xsZWN0aW9uRGVmLkFueUxpc3RIABoZCghOb2RlTGlzdBINCgV2",
            "YWx1ZRgBIAMoCRoaCglCeXRlc0xpc3QSDQoFdmFsdWUYASADKAwaHgoJSW50",
            "NjRMaXN0EhEKBXZhbHVlGAEgAygDQgIQARoeCglGbG9hdExpc3QSEQoFdmFs",
            "dWUYASADKAJCAhABGi4KB0FueUxpc3QSIwoFdmFsdWUYASADKAsyFC5nb29n",
            "bGUucHJvdG9idWYuQW55QgYKBGtpbmQioAIKClRlbnNvckluZm8SDgoEbmFt",
            "ZRgBIAEoCUgAEjYKCmNvb19zcGFyc2UYBCABKAsyIC50ZW5zb3JmbG93LlRl",
            "bnNvckluZm8uQ29vU3BhcnNlSAASIwoFZHR5cGUYAiABKA4yFC50ZW5zb3Jm",
            "bG93LkRhdGFUeXBlEjIKDHRlbnNvcl9zaGFwZRgDIAEoCzIcLnRlbnNvcmZs",
            "b3cuVGVuc29yU2hhcGVQcm90bxplCglDb29TcGFyc2USGgoSdmFsdWVzX3Rl",
            "bnNvcl9uYW1lGAEgASgJEhsKE2luZGljZXNfdGVuc29yX25hbWUYAiABKAkS",
            "HwoXZGVuc2Vfc2hhcGVfdGVuc29yX25hbWUYAyABKAlCCgoIZW5jb2Rpbmci",
            "oAIKDFNpZ25hdHVyZURlZhI0CgZpbnB1dHMYASADKAsyJC50ZW5zb3JmbG93",
            "LlNpZ25hdHVyZURlZi5JbnB1dHNFbnRyeRI2CgdvdXRwdXRzGAIgAygLMiUu",
            "dGVuc29yZmxvdy5TaWduYXR1cmVEZWYuT3V0cHV0c0VudHJ5EhMKC21ldGhv",
            "ZF9uYW1lGAMgASgJGkUKC0lucHV0c0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2",
            "YWx1ZRgCIAEoCzIWLnRlbnNvcmZsb3cuVGVuc29ySW5mbzoCOAEaRgoMT3V0",
            "cHV0c0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLnRlbnNv",
            "cmZsb3cuVGVuc29ySW5mbzoCOAEiTQoMQXNzZXRGaWxlRGVmEisKC3RlbnNv",
            "cl9pbmZvGAEgASgLMhYudGVuc29yZmxvdy5UZW5zb3JJbmZvEhAKCGZpbGVu",
            "YW1lGAIgASgJQm4KGG9yZy50ZW5zb3JmbG93LmZyYW1ld29ya0IPTWV0YUdy",
            "YXBoUHJvdG9zUAFaPGdpdGh1Yi5jb20vdGVuc29yZmxvdy90ZW5zb3JmbG93",
            "L3RlbnNvcmZsb3cvZ28vY29yZS9wcm90b2J1ZvgBAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Tensorflow.GraphReflection.Descriptor, global::Tensorflow.OpDefReflection.Descriptor, global::Tensorflow.TensorShapeReflection.Descriptor, global::Tensorflow.TypesReflection.Descriptor, global::Tensorflow.SaverReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.MetaGraphDef), global::Tensorflow.MetaGraphDef.Parser, new[]{ "MetaInfoDef", "GraphDef", "SaverDef", "CollectionDef", "SignatureDef", "AssetFileDef" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.MetaGraphDef.Types.MetaInfoDef), global::Tensorflow.MetaGraphDef.Types.MetaInfoDef.Parser, new[]{ "MetaGraphVersion", "StrippedOpList", "AnyInfo", "Tags", "TensorflowVersion", "TensorflowGitVersion", "StrippedDefaultAttrs" }, null, null, null),
            null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef), global::Tensorflow.CollectionDef.Parser, new[]{ "NodeList", "BytesList", "Int64List", "FloatList", "AnyList" }, new[]{ "Kind" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef.Types.NodeList), global::Tensorflow.CollectionDef.Types.NodeList.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef.Types.BytesList), global::Tensorflow.CollectionDef.Types.BytesList.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef.Types.Int64List), global::Tensorflow.CollectionDef.Types.Int64List.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef.Types.FloatList), global::Tensorflow.CollectionDef.Types.FloatList.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.CollectionDef.Types.AnyList), global::Tensorflow.CollectionDef.Types.AnyList.Parser, new[]{ "Value" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.TensorInfo), global::Tensorflow.TensorInfo.Parser, new[]{ "Name", "CooSparse", "Dtype", "TensorShape" }, new[]{ "Encoding" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.TensorInfo.Types.CooSparse), global::Tensorflow.TensorInfo.Types.CooSparse.Parser, new[]{ "ValuesTensorName", "IndicesTensorName", "DenseShapeTensorName" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.SignatureDef), global::Tensorflow.SignatureDef.Parser, new[]{ "Inputs", "Outputs", "MethodName" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.AssetFileDef), global::Tensorflow.AssetFileDef.Parser, new[]{ "TensorInfo", "Filename" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// NOTE: This protocol buffer is evolving, and will go through revisions in the
  /// coming months.
  ///
  /// Protocol buffer containing the following which are necessary to restart
  /// training, run inference. It can be used to serialize/de-serialize memory
  /// objects necessary for running computation in a graph when crossing the
  /// process boundary. It can be used for long term storage of graphs,
  /// cross-language execution of graphs, etc.
  ///   MetaInfoDef
  ///   GraphDef
  ///   SaverDef
  ///   CollectionDef
  ///   TensorInfo
  ///   SignatureDef
  /// </summary>
  public sealed partial class MetaGraphDef : pb::IMessage<MetaGraphDef> {
    private static readonly pb::MessageParser<MetaGraphDef> _parser = new pb::MessageParser<MetaGraphDef>(() => new MetaGraphDef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MetaGraphDef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.MetaGraphReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MetaGraphDef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MetaGraphDef(MetaGraphDef other) : this() {
      metaInfoDef_ = other.metaInfoDef_ != null ? other.metaInfoDef_.Clone() : null;
      graphDef_ = other.graphDef_ != null ? other.graphDef_.Clone() : null;
      saverDef_ = other.saverDef_ != null ? other.saverDef_.Clone() : null;
      collectionDef_ = other.collectionDef_.Clone();
      signatureDef_ = other.signatureDef_.Clone();
      assetFileDef_ = other.assetFileDef_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MetaGraphDef Clone() {
      return new MetaGraphDef(this);
    }

    /// <summary>Field number for the "meta_info_def" field.</summary>
    public const int MetaInfoDefFieldNumber = 1;
    private global::Tensorflow.MetaGraphDef.Types.MetaInfoDef metaInfoDef_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.MetaGraphDef.Types.MetaInfoDef MetaInfoDef {
      get { return metaInfoDef_; }
      set {
        metaInfoDef_ = value;
      }
    }

    /// <summary>Field number for the "graph_def" field.</summary>
    public const int GraphDefFieldNumber = 2;
    private global::Tensorflow.GraphDef graphDef_;
    /// <summary>
    /// GraphDef.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.GraphDef GraphDef {
      get { return graphDef_; }
      set {
        graphDef_ = value;
      }
    }

    /// <summary>Field number for the "saver_def" field.</summary>
    public const int SaverDefFieldNumber = 3;
    private global::Tensorflow.SaverDef saverDef_;
    /// <summary>
    /// SaverDef.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.SaverDef SaverDef {
      get { return saverDef_; }
      set {
        saverDef_ = value;
      }
    }

    /// <summary>Field number for the "collection_def" field.</summary>
    public const int CollectionDefFieldNumber = 4;
    private static readonly pbc::MapField<string, global::Tensorflow.CollectionDef>.Codec _map_collectionDef_codec
        = new pbc::MapField<string, global::Tensorflow.CollectionDef>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Tensorflow.CollectionDef.Parser), 34);
    private readonly pbc::MapField<string, global::Tensorflow.CollectionDef> collectionDef_ = new pbc::MapField<string, global::Tensorflow.CollectionDef>();
    /// <summary>
    /// collection_def: Map from collection name to collections.
    /// See CollectionDef section for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Tensorflow.CollectionDef> CollectionDef {
      get { return collectionDef_; }
    }

    /// <summary>Field number for the "signature_def" field.</summary>
    public const int SignatureDefFieldNumber = 5;
    private static readonly pbc::MapField<string, global::Tensorflow.SignatureDef>.Codec _map_signatureDef_codec
        = new pbc::MapField<string, global::Tensorflow.SignatureDef>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Tensorflow.SignatureDef.Parser), 42);
    private readonly pbc::MapField<string, global::Tensorflow.SignatureDef> signatureDef_ = new pbc::MapField<string, global::Tensorflow.SignatureDef>();
    /// <summary>
    /// signature_def: Map from user supplied key for a signature to a single
    /// SignatureDef.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Tensorflow.SignatureDef> SignatureDef {
      get { return signatureDef_; }
    }

    /// <summary>Field number for the "asset_file_def" field.</summary>
    public const int AssetFileDefFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Tensorflow.AssetFileDef> _repeated_assetFileDef_codec
        = pb::FieldCodec.ForMessage(50, global::Tensorflow.AssetFileDef.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.AssetFileDef> assetFileDef_ = new pbc::RepeatedField<global::Tensorflow.AssetFileDef>();
    /// <summary>
    /// Asset file def to be used with the defined graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.AssetFileDef> AssetFileDef {
      get { return assetFileDef_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MetaGraphDef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MetaGraphDef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MetaInfoDef, other.MetaInfoDef)) return false;
      if (!object.Equals(GraphDef, other.GraphDef)) return false;
      if (!object.Equals(SaverDef, other.SaverDef)) return false;
      if (!CollectionDef.Equals(other.CollectionDef)) return false;
      if (!SignatureDef.Equals(other.SignatureDef)) return false;
      if(!assetFileDef_.Equals(other.assetFileDef_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (metaInfoDef_ != null) hash ^= MetaInfoDef.GetHashCode();
      if (graphDef_ != null) hash ^= GraphDef.GetHashCode();
      if (saverDef_ != null) hash ^= SaverDef.GetHashCode();
      hash ^= CollectionDef.GetHashCode();
      hash ^= SignatureDef.GetHashCode();
      hash ^= assetFileDef_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (metaInfoDef_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MetaInfoDef);
      }
      if (graphDef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(GraphDef);
      }
      if (saverDef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SaverDef);
      }
      collectionDef_.WriteTo(output, _map_collectionDef_codec);
      signatureDef_.WriteTo(output, _map_signatureDef_codec);
      assetFileDef_.WriteTo(output, _repeated_assetFileDef_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (metaInfoDef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetaInfoDef);
      }
      if (graphDef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GraphDef);
      }
      if (saverDef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SaverDef);
      }
      size += collectionDef_.CalculateSize(_map_collectionDef_codec);
      size += signatureDef_.CalculateSize(_map_signatureDef_codec);
      size += assetFileDef_.CalculateSize(_repeated_assetFileDef_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MetaGraphDef other) {
      if (other == null) {
        return;
      }
      if (other.metaInfoDef_ != null) {
        if (metaInfoDef_ == null) {
          metaInfoDef_ = new global::Tensorflow.MetaGraphDef.Types.MetaInfoDef();
        }
        MetaInfoDef.MergeFrom(other.MetaInfoDef);
      }
      if (other.graphDef_ != null) {
        if (graphDef_ == null) {
          graphDef_ = new global::Tensorflow.GraphDef();
        }
        GraphDef.MergeFrom(other.GraphDef);
      }
      if (other.saverDef_ != null) {
        if (saverDef_ == null) {
          saverDef_ = new global::Tensorflow.SaverDef();
        }
        SaverDef.MergeFrom(other.SaverDef);
      }
      collectionDef_.Add(other.collectionDef_);
      signatureDef_.Add(other.signatureDef_);
      assetFileDef_.Add(other.assetFileDef_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metaInfoDef_ == null) {
              metaInfoDef_ = new global::Tensorflow.MetaGraphDef.Types.MetaInfoDef();
            }
            input.ReadMessage(metaInfoDef_);
            break;
          }
          case 18: {
            if (graphDef_ == null) {
              graphDef_ = new global::Tensorflow.GraphDef();
            }
            input.ReadMessage(graphDef_);
            break;
          }
          case 26: {
            if (saverDef_ == null) {
              saverDef_ = new global::Tensorflow.SaverDef();
            }
            input.ReadMessage(saverDef_);
            break;
          }
          case 34: {
            collectionDef_.AddEntriesFrom(input, _map_collectionDef_codec);
            break;
          }
          case 42: {
            signatureDef_.AddEntriesFrom(input, _map_signatureDef_codec);
            break;
          }
          case 50: {
            assetFileDef_.AddEntriesFrom(input, _repeated_assetFileDef_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MetaGraphDef message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Meta information regarding the graph to be exported.  To be used by users
      /// of this protocol buffer to encode information regarding their meta graph.
      /// </summary>
      public sealed partial class MetaInfoDef : pb::IMessage<MetaInfoDef> {
        private static readonly pb::MessageParser<MetaInfoDef> _parser = new pb::MessageParser<MetaInfoDef>(() => new MetaInfoDef());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MetaInfoDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.MetaGraphDef.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MetaInfoDef() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MetaInfoDef(MetaInfoDef other) : this() {
          metaGraphVersion_ = other.metaGraphVersion_;
          strippedOpList_ = other.strippedOpList_ != null ? other.strippedOpList_.Clone() : null;
          anyInfo_ = other.anyInfo_ != null ? other.anyInfo_.Clone() : null;
          tags_ = other.tags_.Clone();
          tensorflowVersion_ = other.tensorflowVersion_;
          tensorflowGitVersion_ = other.tensorflowGitVersion_;
          strippedDefaultAttrs_ = other.strippedDefaultAttrs_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MetaInfoDef Clone() {
          return new MetaInfoDef(this);
        }

        /// <summary>Field number for the "meta_graph_version" field.</summary>
        public const int MetaGraphVersionFieldNumber = 1;
        private string metaGraphVersion_ = "";
        /// <summary>
        /// User specified Version string. Can be the name of the model and revision,
        /// steps this model has been trained to, etc.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string MetaGraphVersion {
          get { return metaGraphVersion_; }
          set {
            metaGraphVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "stripped_op_list" field.</summary>
        public const int StrippedOpListFieldNumber = 2;
        private global::Tensorflow.OpList strippedOpList_;
        /// <summary>
        /// A copy of the OpDefs used by the producer of this graph_def.
        /// Descriptions and Ops not used in graph_def are stripped out.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Tensorflow.OpList StrippedOpList {
          get { return strippedOpList_; }
          set {
            strippedOpList_ = value;
          }
        }

        /// <summary>Field number for the "any_info" field.</summary>
        public const int AnyInfoFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Any anyInfo_;
        /// <summary>
        /// A serialized protobuf. Can be the time this meta graph is created, or
        /// modified, or name of the model.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any AnyInfo {
          get { return anyInfo_; }
          set {
            anyInfo_ = value;
          }
        }

        /// <summary>Field number for the "tags" field.</summary>
        public const int TagsFieldNumber = 4;
        private static readonly pb::FieldCodec<string> _repeated_tags_codec
            = pb::FieldCodec.ForString(34);
        private readonly pbc::RepeatedField<string> tags_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// User supplied tag(s) on the meta_graph and included graph_def.
        ///
        /// MetaGraphDefs should be tagged with their capabilities or use-cases.
        /// Examples: "train", "serve", "gpu", "tpu", etc.
        /// These tags enable loaders to access the MetaGraph(s) appropriate for a
        /// specific use-case or runtime environment.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Tags {
          get { return tags_; }
        }

        /// <summary>Field number for the "tensorflow_version" field.</summary>
        public const int TensorflowVersionFieldNumber = 5;
        private string tensorflowVersion_ = "";
        /// <summary>
        /// The __version__ string of the tensorflow build used to write this graph.
        /// This will be populated by the framework, which will overwrite any user
        /// supplied value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TensorflowVersion {
          get { return tensorflowVersion_; }
          set {
            tensorflowVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "tensorflow_git_version" field.</summary>
        public const int TensorflowGitVersionFieldNumber = 6;
        private string tensorflowGitVersion_ = "";
        /// <summary>
        /// The __git_version__ string of the tensorflow build used to write this
        /// graph. This will be populated by the framework, which will overwrite any
        /// user supplied value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TensorflowGitVersion {
          get { return tensorflowGitVersion_; }
          set {
            tensorflowGitVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "stripped_default_attrs" field.</summary>
        public const int StrippedDefaultAttrsFieldNumber = 7;
        private bool strippedDefaultAttrs_;
        /// <summary>
        /// A flag to denote whether default-valued attrs have been stripped from
        /// the nodes in this graph_def.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool StrippedDefaultAttrs {
          get { return strippedDefaultAttrs_; }
          set {
            strippedDefaultAttrs_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MetaInfoDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MetaInfoDef other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MetaGraphVersion != other.MetaGraphVersion) return false;
          if (!object.Equals(StrippedOpList, other.StrippedOpList)) return false;
          if (!object.Equals(AnyInfo, other.AnyInfo)) return false;
          if(!tags_.Equals(other.tags_)) return false;
          if (TensorflowVersion != other.TensorflowVersion) return false;
          if (TensorflowGitVersion != other.TensorflowGitVersion) return false;
          if (StrippedDefaultAttrs != other.StrippedDefaultAttrs) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MetaGraphVersion.Length != 0) hash ^= MetaGraphVersion.GetHashCode();
          if (strippedOpList_ != null) hash ^= StrippedOpList.GetHashCode();
          if (anyInfo_ != null) hash ^= AnyInfo.GetHashCode();
          hash ^= tags_.GetHashCode();
          if (TensorflowVersion.Length != 0) hash ^= TensorflowVersion.GetHashCode();
          if (TensorflowGitVersion.Length != 0) hash ^= TensorflowGitVersion.GetHashCode();
          if (StrippedDefaultAttrs != false) hash ^= StrippedDefaultAttrs.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MetaGraphVersion.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(MetaGraphVersion);
          }
          if (strippedOpList_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(StrippedOpList);
          }
          if (anyInfo_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(AnyInfo);
          }
          tags_.WriteTo(output, _repeated_tags_codec);
          if (TensorflowVersion.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(TensorflowVersion);
          }
          if (TensorflowGitVersion.Length != 0) {
            output.WriteRawTag(50);
            output.WriteString(TensorflowGitVersion);
          }
          if (StrippedDefaultAttrs != false) {
            output.WriteRawTag(56);
            output.WriteBool(StrippedDefaultAttrs);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MetaGraphVersion.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(MetaGraphVersion);
          }
          if (strippedOpList_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StrippedOpList);
          }
          if (anyInfo_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AnyInfo);
          }
          size += tags_.CalculateSize(_repeated_tags_codec);
          if (TensorflowVersion.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TensorflowVersion);
          }
          if (TensorflowGitVersion.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TensorflowGitVersion);
          }
          if (StrippedDefaultAttrs != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MetaInfoDef other) {
          if (other == null) {
            return;
          }
          if (other.MetaGraphVersion.Length != 0) {
            MetaGraphVersion = other.MetaGraphVersion;
          }
          if (other.strippedOpList_ != null) {
            if (strippedOpList_ == null) {
              strippedOpList_ = new global::Tensorflow.OpList();
            }
            StrippedOpList.MergeFrom(other.StrippedOpList);
          }
          if (other.anyInfo_ != null) {
            if (anyInfo_ == null) {
              anyInfo_ = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            AnyInfo.MergeFrom(other.AnyInfo);
          }
          tags_.Add(other.tags_);
          if (other.TensorflowVersion.Length != 0) {
            TensorflowVersion = other.TensorflowVersion;
          }
          if (other.TensorflowGitVersion.Length != 0) {
            TensorflowGitVersion = other.TensorflowGitVersion;
          }
          if (other.StrippedDefaultAttrs != false) {
            StrippedDefaultAttrs = other.StrippedDefaultAttrs;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                MetaGraphVersion = input.ReadString();
                break;
              }
              case 18: {
                if (strippedOpList_ == null) {
                  strippedOpList_ = new global::Tensorflow.OpList();
                }
                input.ReadMessage(strippedOpList_);
                break;
              }
              case 26: {
                if (anyInfo_ == null) {
                  anyInfo_ = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(anyInfo_);
                break;
              }
              case 34: {
                tags_.AddEntriesFrom(input, _repeated_tags_codec);
                break;
              }
              case 42: {
                TensorflowVersion = input.ReadString();
                break;
              }
              case 50: {
                TensorflowGitVersion = input.ReadString();
                break;
              }
              case 56: {
                StrippedDefaultAttrs = input.ReadBool();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// CollectionDef should cover most collections.
  /// To add a user-defined collection, do one of the following:
  /// 1. For simple data types, such as string, int, float:
  ///      tf.add_to_collection("your_collection_name", your_simple_value)
  ///    strings will be stored as bytes_list.
  ///
  /// 2. For Protobuf types, there are three ways to add them:
  ///    1) tf.add_to_collection("your_collection_name",
  ///         your_proto.SerializeToString())
  ///
  ///       collection_def {
  ///         key: "user_defined_bytes_collection"
  ///         value {
  ///           bytes_list {
  ///             value: "queue_name: \"test_queue\"\n"
  ///           }
  ///         }
  ///       }
  ///
  ///  or
  ///
  ///    2) tf.add_to_collection("your_collection_name", str(your_proto))
  ///
  ///       collection_def {
  ///         key: "user_defined_string_collection"
  ///         value {
  ///          bytes_list {
  ///             value: "\n\ntest_queue"
  ///           }
  ///         }
  ///       }
  ///
  ///  or
  ///
  ///    3) any_buf = any_pb2.Any()
  ///       tf.add_to_collection("your_collection_name",
  ///         any_buf.Pack(your_proto))
  ///
  ///       collection_def {
  ///         key: "user_defined_any_collection"
  ///         value {
  ///           any_list {
  ///             value {
  ///               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
  ///               value: "\n\ntest_queue"
  ///             }
  ///           }
  ///         }
  ///       }
  ///
  /// 3. For Python objects, implement to_proto() and from_proto(), and register
  ///    them in the following manner:
  ///    ops.register_proto_function("your_collection_name",
  ///                                proto_type,
  ///                                to_proto=YourPythonObject.to_proto,
  ///                                from_proto=YourPythonObject.from_proto)
  ///    These functions will be invoked to serialize and de-serialize the
  ///    collection. For example,
  ///    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
  ///                                proto_type=variable_pb2.VariableDef,
  ///                                to_proto=Variable.to_proto,
  ///                                from_proto=Variable.from_proto)
  /// </summary>
  public sealed partial class CollectionDef : pb::IMessage<CollectionDef> {
    private static readonly pb::MessageParser<CollectionDef> _parser = new pb::MessageParser<CollectionDef>(() => new CollectionDef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CollectionDef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.MetaGraphReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollectionDef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollectionDef(CollectionDef other) : this() {
      switch (other.KindCase) {
        case KindOneofCase.NodeList:
          NodeList = other.NodeList.Clone();
          break;
        case KindOneofCase.BytesList:
          BytesList = other.BytesList.Clone();
          break;
        case KindOneofCase.Int64List:
          Int64List = other.Int64List.Clone();
          break;
        case KindOneofCase.FloatList:
          FloatList = other.FloatList.Clone();
          break;
        case KindOneofCase.AnyList:
          AnyList = other.AnyList.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollectionDef Clone() {
      return new CollectionDef(this);
    }

    /// <summary>Field number for the "node_list" field.</summary>
    public const int NodeListFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.CollectionDef.Types.NodeList NodeList {
      get { return kindCase_ == KindOneofCase.NodeList ? (global::Tensorflow.CollectionDef.Types.NodeList) kind_ : null; }
      set {
        kind_ = value;
        kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.NodeList;
      }
    }

    /// <summary>Field number for the "bytes_list" field.</summary>
    public const int BytesListFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.CollectionDef.Types.BytesList BytesList {
      get { return kindCase_ == KindOneofCase.BytesList ? (global::Tensorflow.CollectionDef.Types.BytesList) kind_ : null; }
      set {
        kind_ = value;
        kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.BytesList;
      }
    }

    /// <summary>Field number for the "int64_list" field.</summary>
    public const int Int64ListFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.CollectionDef.Types.Int64List Int64List {
      get { return kindCase_ == KindOneofCase.Int64List ? (global::Tensorflow.CollectionDef.Types.Int64List) kind_ : null; }
      set {
        kind_ = value;
        kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.Int64List;
      }
    }

    /// <summary>Field number for the "float_list" field.</summary>
    public const int FloatListFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.CollectionDef.Types.FloatList FloatList {
      get { return kindCase_ == KindOneofCase.FloatList ? (global::Tensorflow.CollectionDef.Types.FloatList) kind_ : null; }
      set {
        kind_ = value;
        kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.FloatList;
      }
    }

    /// <summary>Field number for the "any_list" field.</summary>
    public const int AnyListFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.CollectionDef.Types.AnyList AnyList {
      get { return kindCase_ == KindOneofCase.AnyList ? (global::Tensorflow.CollectionDef.Types.AnyList) kind_ : null; }
      set {
        kind_ = value;
        kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.AnyList;
      }
    }

    private object kind_;
    /// <summary>Enum of possible cases for the "kind" oneof.</summary>
    public enum KindOneofCase {
      None = 0,
      NodeList = 1,
      BytesList = 2,
      Int64List = 3,
      FloatList = 4,
      AnyList = 5,
    }
    private KindOneofCase kindCase_ = KindOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KindOneofCase KindCase {
      get { return kindCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKind() {
      kindCase_ = KindOneofCase.None;
      kind_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CollectionDef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CollectionDef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(NodeList, other.NodeList)) return false;
      if (!object.Equals(BytesList, other.BytesList)) return false;
      if (!object.Equals(Int64List, other.Int64List)) return false;
      if (!object.Equals(FloatList, other.FloatList)) return false;
      if (!object.Equals(AnyList, other.AnyList)) return false;
      if (KindCase != other.KindCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (kindCase_ == KindOneofCase.NodeList) hash ^= NodeList.GetHashCode();
      if (kindCase_ == KindOneofCase.BytesList) hash ^= BytesList.GetHashCode();
      if (kindCase_ == KindOneofCase.Int64List) hash ^= Int64List.GetHashCode();
      if (kindCase_ == KindOneofCase.FloatList) hash ^= FloatList.GetHashCode();
      if (kindCase_ == KindOneofCase.AnyList) hash ^= AnyList.GetHashCode();
      hash ^= (int) kindCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (kindCase_ == KindOneofCase.NodeList) {
        output.WriteRawTag(10);
        output.WriteMessage(NodeList);
      }
      if (kindCase_ == KindOneofCase.BytesList) {
        output.WriteRawTag(18);
        output.WriteMessage(BytesList);
      }
      if (kindCase_ == KindOneofCase.Int64List) {
        output.WriteRawTag(26);
        output.WriteMessage(Int64List);
      }
      if (kindCase_ == KindOneofCase.FloatList) {
        output.WriteRawTag(34);
        output.WriteMessage(FloatList);
      }
      if (kindCase_ == KindOneofCase.AnyList) {
        output.WriteRawTag(42);
        output.WriteMessage(AnyList);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (kindCase_ == KindOneofCase.NodeList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeList);
      }
      if (kindCase_ == KindOneofCase.BytesList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BytesList);
      }
      if (kindCase_ == KindOneofCase.Int64List) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Int64List);
      }
      if (kindCase_ == KindOneofCase.FloatList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FloatList);
      }
      if (kindCase_ == KindOneofCase.AnyList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AnyList);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CollectionDef other) {
      if (other == null) {
        return;
      }
      switch (other.KindCase) {
        case KindOneofCase.NodeList:
          if (NodeList == null) {
            NodeList = new global::Tensorflow.CollectionDef.Types.NodeList();
          }
          NodeList.MergeFrom(other.NodeList);
          break;
        case KindOneofCase.BytesList:
          if (BytesList == null) {
            BytesList = new global::Tensorflow.CollectionDef.Types.BytesList();
          }
          BytesList.MergeFrom(other.BytesList);
          break;
        case KindOneofCase.Int64List:
          if (Int64List == null) {
            Int64List = new global::Tensorflow.CollectionDef.Types.Int64List();
          }
          Int64List.MergeFrom(other.Int64List);
          break;
        case KindOneofCase.FloatList:
          if (FloatList == null) {
            FloatList = new global::Tensorflow.CollectionDef.Types.FloatList();
          }
          FloatList.MergeFrom(other.FloatList);
          break;
        case KindOneofCase.AnyList:
          if (AnyList == null) {
            AnyList = new global::Tensorflow.CollectionDef.Types.AnyList();
          }
          AnyList.MergeFrom(other.AnyList);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Tensorflow.CollectionDef.Types.NodeList subBuilder = new global::Tensorflow.CollectionDef.Types.NodeList();
            if (kindCase_ == KindOneofCase.NodeList) {
              subBuilder.MergeFrom(NodeList);
            }
            input.ReadMessage(subBuilder);
            NodeList = subBuilder;
            break;
          }
          case 18: {
            global::Tensorflow.CollectionDef.Types.BytesList subBuilder = new global::Tensorflow.CollectionDef.Types.BytesList();
            if (kindCase_ == KindOneofCase.BytesList) {
              subBuilder.MergeFrom(BytesList);
            }
            input.ReadMessage(subBuilder);
            BytesList = subBuilder;
            break;
          }
          case 26: {
            global::Tensorflow.CollectionDef.Types.Int64List subBuilder = new global::Tensorflow.CollectionDef.Types.Int64List();
            if (kindCase_ == KindOneofCase.Int64List) {
              subBuilder.MergeFrom(Int64List);
            }
            input.ReadMessage(subBuilder);
            Int64List = subBuilder;
            break;
          }
          case 34: {
            global::Tensorflow.CollectionDef.Types.FloatList subBuilder = new global::Tensorflow.CollectionDef.Types.FloatList();
            if (kindCase_ == KindOneofCase.FloatList) {
              subBuilder.MergeFrom(FloatList);
            }
            input.ReadMessage(subBuilder);
            FloatList = subBuilder;
            break;
          }
          case 42: {
            global::Tensorflow.CollectionDef.Types.AnyList subBuilder = new global::Tensorflow.CollectionDef.Types.AnyList();
            if (kindCase_ == KindOneofCase.AnyList) {
              subBuilder.MergeFrom(AnyList);
            }
            input.ReadMessage(subBuilder);
            AnyList = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CollectionDef message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// NodeList is used for collecting nodes in graph. For example
      /// collection_def {
      ///   key: "summaries"
      ///   value {
      ///     node_list {
      ///       value: "input_producer/ScalarSummary:0"
      ///       value: "shuffle_batch/ScalarSummary:0"
      ///       value: "ImageSummary:0"
      ///     }
      ///   }
      /// </summary>
      public sealed partial class NodeList : pb::IMessage<NodeList> {
        private static readonly pb::MessageParser<NodeList> _parser = new pb::MessageParser<NodeList>(() => new NodeList());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NodeList> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.CollectionDef.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NodeList() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NodeList(NodeList other) : this() {
          value_ = other.value_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NodeList Clone() {
          return new NodeList(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_value_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> value_ = new pbc::RepeatedField<string>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Value {
          get { return value_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NodeList);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NodeList other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!value_.Equals(other.value_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= value_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          value_.WriteTo(output, _repeated_value_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += value_.CalculateSize(_repeated_value_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NodeList other) {
          if (other == null) {
            return;
          }
          value_.Add(other.value_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                value_.AddEntriesFrom(input, _repeated_value_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// BytesList is used for collecting strings and serialized protobufs. For
      /// example:
      /// collection_def {
      ///   key: "trainable_variables"
      ///   value {
      ///     bytes_list {
      ///       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
      ///              \032\024conv1/weights/read:0"
      ///       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
      ///              \023conv1/biases/read:0"
      ///     }
      ///   }
      /// }
      /// </summary>
      public sealed partial class BytesList : pb::IMessage<BytesList> {
        private static readonly pb::MessageParser<BytesList> _parser = new pb::MessageParser<BytesList>(() => new BytesList());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BytesList> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.CollectionDef.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BytesList() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BytesList(BytesList other) : this() {
          value_ = other.value_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BytesList Clone() {
          return new BytesList(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private static readonly pb::FieldCodec<pb::ByteString> _repeated_value_codec
            = pb::FieldCodec.ForBytes(10);
        private readonly pbc::RepeatedField<pb::ByteString> value_ = new pbc::RepeatedField<pb::ByteString>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<pb::ByteString> Value {
          get { return value_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BytesList);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BytesList other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!value_.Equals(other.value_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= value_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          value_.WriteTo(output, _repeated_value_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += value_.CalculateSize(_repeated_value_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BytesList other) {
          if (other == null) {
            return;
          }
          value_.Add(other.value_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                value_.AddEntriesFrom(input, _repeated_value_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Int64List is used for collecting int, int64 and long values.
      /// </summary>
      public sealed partial class Int64List : pb::IMessage<Int64List> {
        private static readonly pb::MessageParser<Int64List> _parser = new pb::MessageParser<Int64List>(() => new Int64List());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Int64List> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.CollectionDef.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Int64List() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Int64List(Int64List other) : this() {
          value_ = other.value_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Int64List Clone() {
          return new Int64List(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_value_codec
            = pb::FieldCodec.ForInt64(10);
        private readonly pbc::RepeatedField<long> value_ = new pbc::RepeatedField<long>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Value {
          get { return value_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Int64List);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Int64List other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!value_.Equals(other.value_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= value_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          value_.WriteTo(output, _repeated_value_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += value_.CalculateSize(_repeated_value_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Int64List other) {
          if (other == null) {
            return;
          }
          value_.Add(other.value_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 8: {
                value_.AddEntriesFrom(input, _repeated_value_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// FloatList is used for collecting float values.
      /// </summary>
      public sealed partial class FloatList : pb::IMessage<FloatList> {
        private static readonly pb::MessageParser<FloatList> _parser = new pb::MessageParser<FloatList>(() => new FloatList());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<FloatList> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.CollectionDef.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FloatList() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FloatList(FloatList other) : this() {
          value_ = other.value_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FloatList Clone() {
          return new FloatList(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private static readonly pb::FieldCodec<float> _repeated_value_codec
            = pb::FieldCodec.ForFloat(10);
        private readonly pbc::RepeatedField<float> value_ = new pbc::RepeatedField<float>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<float> Value {
          get { return value_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as FloatList);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(FloatList other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!value_.Equals(other.value_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= value_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          value_.WriteTo(output, _repeated_value_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += value_.CalculateSize(_repeated_value_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(FloatList other) {
          if (other == null) {
            return;
          }
          value_.Add(other.value_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 13: {
                value_.AddEntriesFrom(input, _repeated_value_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// AnyList is used for collecting Any protos.
      /// </summary>
      public sealed partial class AnyList : pb::IMessage<AnyList> {
        private static readonly pb::MessageParser<AnyList> _parser = new pb::MessageParser<AnyList>(() => new AnyList());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AnyList> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.CollectionDef.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AnyList() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AnyList(AnyList other) : this() {
          value_ = other.value_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AnyList Clone() {
          return new AnyList(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Any> _repeated_value_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Protobuf.WellKnownTypes.Any.Parser);
        private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> value_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> Value {
          get { return value_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AnyList);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AnyList other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!value_.Equals(other.value_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= value_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          value_.WriteTo(output, _repeated_value_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += value_.CalculateSize(_repeated_value_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AnyList other) {
          if (other == null) {
            return;
          }
          value_.Add(other.value_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                value_.AddEntriesFrom(input, _repeated_value_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about a Tensor necessary for feeding or retrieval.
  /// </summary>
  public sealed partial class TensorInfo : pb::IMessage<TensorInfo> {
    private static readonly pb::MessageParser<TensorInfo> _parser = new pb::MessageParser<TensorInfo>(() => new TensorInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TensorInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.MetaGraphReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorInfo(TensorInfo other) : this() {
      dtype_ = other.dtype_;
      tensorShape_ = other.tensorShape_ != null ? other.tensorShape_.Clone() : null;
      switch (other.EncodingCase) {
        case EncodingOneofCase.Name:
          Name = other.Name;
          break;
        case EncodingOneofCase.CooSparse:
          CooSparse = other.CooSparse.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorInfo Clone() {
      return new TensorInfo(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    /// <summary>
    /// For dense `Tensor`s, the name of the tensor in the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return encodingCase_ == EncodingOneofCase.Name ? (string) encoding_ : ""; }
      set {
        encoding_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        encodingCase_ = EncodingOneofCase.Name;
      }
    }

    /// <summary>Field number for the "coo_sparse" field.</summary>
    public const int CooSparseFieldNumber = 4;
    /// <summary>
    /// There are many possible encodings of sparse matrices
    /// (https://en.wikipedia.org/wiki/Sparse_matrix).  Currently, TensorFlow
    /// uses only the COO encoding.  This is supported and documented in the
    /// SparseTensor Python class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.TensorInfo.Types.CooSparse CooSparse {
      get { return encodingCase_ == EncodingOneofCase.CooSparse ? (global::Tensorflow.TensorInfo.Types.CooSparse) encoding_ : null; }
      set {
        encoding_ = value;
        encodingCase_ = value == null ? EncodingOneofCase.None : EncodingOneofCase.CooSparse;
      }
    }

    /// <summary>Field number for the "dtype" field.</summary>
    public const int DtypeFieldNumber = 2;
    private global::Tensorflow.DataType dtype_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.DataType Dtype {
      get { return dtype_; }
      set {
        dtype_ = value;
      }
    }

    /// <summary>Field number for the "tensor_shape" field.</summary>
    public const int TensorShapeFieldNumber = 3;
    private global::Tensorflow.TensorShapeProto tensorShape_;
    /// <summary>
    /// The static shape should be recorded here, to the extent that it can
    /// be known in advance.  In the case of a SparseTensor, this field describes
    /// the logical shape of the represented tensor (aka dense_shape).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.TensorShapeProto TensorShape {
      get { return tensorShape_; }
      set {
        tensorShape_ = value;
      }
    }

    private object encoding_;
    /// <summary>Enum of possible cases for the "encoding" oneof.</summary>
    public enum EncodingOneofCase {
      None = 0,
      Name = 1,
      CooSparse = 4,
    }
    private EncodingOneofCase encodingCase_ = EncodingOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EncodingOneofCase EncodingCase {
      get { return encodingCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEncoding() {
      encodingCase_ = EncodingOneofCase.None;
      encoding_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TensorInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TensorInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(CooSparse, other.CooSparse)) return false;
      if (Dtype != other.Dtype) return false;
      if (!object.Equals(TensorShape, other.TensorShape)) return false;
      if (EncodingCase != other.EncodingCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (encodingCase_ == EncodingOneofCase.Name) hash ^= Name.GetHashCode();
      if (encodingCase_ == EncodingOneofCase.CooSparse) hash ^= CooSparse.GetHashCode();
      if (Dtype != 0) hash ^= Dtype.GetHashCode();
      if (tensorShape_ != null) hash ^= TensorShape.GetHashCode();
      hash ^= (int) encodingCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (encodingCase_ == EncodingOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Dtype != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Dtype);
      }
      if (tensorShape_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TensorShape);
      }
      if (encodingCase_ == EncodingOneofCase.CooSparse) {
        output.WriteRawTag(34);
        output.WriteMessage(CooSparse);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (encodingCase_ == EncodingOneofCase.Name) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (encodingCase_ == EncodingOneofCase.CooSparse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CooSparse);
      }
      if (Dtype != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Dtype);
      }
      if (tensorShape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TensorShape);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TensorInfo other) {
      if (other == null) {
        return;
      }
      if (other.Dtype != 0) {
        Dtype = other.Dtype;
      }
      if (other.tensorShape_ != null) {
        if (tensorShape_ == null) {
          tensorShape_ = new global::Tensorflow.TensorShapeProto();
        }
        TensorShape.MergeFrom(other.TensorShape);
      }
      switch (other.EncodingCase) {
        case EncodingOneofCase.Name:
          Name = other.Name;
          break;
        case EncodingOneofCase.CooSparse:
          if (CooSparse == null) {
            CooSparse = new global::Tensorflow.TensorInfo.Types.CooSparse();
          }
          CooSparse.MergeFrom(other.CooSparse);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            dtype_ = (global::Tensorflow.DataType) input.ReadEnum();
            break;
          }
          case 26: {
            if (tensorShape_ == null) {
              tensorShape_ = new global::Tensorflow.TensorShapeProto();
            }
            input.ReadMessage(tensorShape_);
            break;
          }
          case 34: {
            global::Tensorflow.TensorInfo.Types.CooSparse subBuilder = new global::Tensorflow.TensorInfo.Types.CooSparse();
            if (encodingCase_ == EncodingOneofCase.CooSparse) {
              subBuilder.MergeFrom(CooSparse);
            }
            input.ReadMessage(subBuilder);
            CooSparse = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TensorInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// For sparse tensors, The COO encoding stores a triple of values, indices,
      /// and shape.
      /// </summary>
      public sealed partial class CooSparse : pb::IMessage<CooSparse> {
        private static readonly pb::MessageParser<CooSparse> _parser = new pb::MessageParser<CooSparse>(() => new CooSparse());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CooSparse> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.TensorInfo.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CooSparse() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CooSparse(CooSparse other) : this() {
          valuesTensorName_ = other.valuesTensorName_;
          indicesTensorName_ = other.indicesTensorName_;
          denseShapeTensorName_ = other.denseShapeTensorName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CooSparse Clone() {
          return new CooSparse(this);
        }

        /// <summary>Field number for the "values_tensor_name" field.</summary>
        public const int ValuesTensorNameFieldNumber = 1;
        private string valuesTensorName_ = "";
        /// <summary>
        /// The shape of the values Tensor is [?].  Its dtype must be the dtype of
        /// the SparseTensor as a whole, given in the enclosing TensorInfo.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ValuesTensorName {
          get { return valuesTensorName_; }
          set {
            valuesTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "indices_tensor_name" field.</summary>
        public const int IndicesTensorNameFieldNumber = 2;
        private string indicesTensorName_ = "";
        /// <summary>
        /// The indices Tensor must have dtype int64 and shape [?, ?].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string IndicesTensorName {
          get { return indicesTensorName_; }
          set {
            indicesTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "dense_shape_tensor_name" field.</summary>
        public const int DenseShapeTensorNameFieldNumber = 3;
        private string denseShapeTensorName_ = "";
        /// <summary>
        /// The dynamic logical shape represented by the SparseTensor is recorded in
        /// the Tensor referenced here.  It must have dtype int64 and shape [?].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DenseShapeTensorName {
          get { return denseShapeTensorName_; }
          set {
            denseShapeTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CooSparse);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CooSparse other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ValuesTensorName != other.ValuesTensorName) return false;
          if (IndicesTensorName != other.IndicesTensorName) return false;
          if (DenseShapeTensorName != other.DenseShapeTensorName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ValuesTensorName.Length != 0) hash ^= ValuesTensorName.GetHashCode();
          if (IndicesTensorName.Length != 0) hash ^= IndicesTensorName.GetHashCode();
          if (DenseShapeTensorName.Length != 0) hash ^= DenseShapeTensorName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ValuesTensorName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(ValuesTensorName);
          }
          if (IndicesTensorName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(IndicesTensorName);
          }
          if (DenseShapeTensorName.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(DenseShapeTensorName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ValuesTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ValuesTensorName);
          }
          if (IndicesTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(IndicesTensorName);
          }
          if (DenseShapeTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DenseShapeTensorName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CooSparse other) {
          if (other == null) {
            return;
          }
          if (other.ValuesTensorName.Length != 0) {
            ValuesTensorName = other.ValuesTensorName;
          }
          if (other.IndicesTensorName.Length != 0) {
            IndicesTensorName = other.IndicesTensorName;
          }
          if (other.DenseShapeTensorName.Length != 0) {
            DenseShapeTensorName = other.DenseShapeTensorName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ValuesTensorName = input.ReadString();
                break;
              }
              case 18: {
                IndicesTensorName = input.ReadString();
                break;
              }
              case 26: {
                DenseShapeTensorName = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// SignatureDef defines the signature of a computation supported by a TensorFlow
  /// graph.
  ///
  /// For example, a model with two loss computations, sharing a single input,
  /// might have the following signature_def map.
  ///
  /// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
  /// output key, and method_name are identical, and will be used by system(s) that
  /// implement or rely upon this particular loss method. The output tensor names
  /// differ, demonstrating how different outputs can exist for the same method.
  ///
  /// signature_def {
  ///   key: "loss_A"
  ///   value {
  ///     inputs {
  ///       key: "input"
  ///       value {
  ///         name: "input:0"
  ///         dtype: DT_STRING
  ///         tensor_shape: ...
  ///       }
  ///     }
  ///     outputs {
  ///       key: "loss_output"
  ///       value {
  ///         name: "loss_output_A:0"
  ///         dtype: DT_FLOAT
  ///         tensor_shape: ...
  ///       }
  ///     }
  ///   }
  ///   ...
  ///   method_name: "some/package/compute_loss"
  /// }
  /// signature_def {
  ///   key: "loss_B"
  ///   value {
  ///     inputs {
  ///       key: "input"
  ///       value {
  ///         name: "input:0"
  ///         dtype: DT_STRING
  ///         tensor_shape: ...
  ///       }
  ///     }
  ///     outputs {
  ///       key: "loss_output"
  ///       value {
  ///         name: "loss_output_B:0"
  ///         dtype: DT_FLOAT
  ///         tensor_shape: ...
  ///       }
  ///     }
  ///   }
  ///   ...
  ///   method_name: "some/package/compute_loss"
  /// }
  /// </summary>
  public sealed partial class SignatureDef : pb::IMessage<SignatureDef> {
    private static readonly pb::MessageParser<SignatureDef> _parser = new pb::MessageParser<SignatureDef>(() => new SignatureDef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignatureDef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.MetaGraphReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDef(SignatureDef other) : this() {
      inputs_ = other.inputs_.Clone();
      outputs_ = other.outputs_.Clone();
      methodName_ = other.methodName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDef Clone() {
      return new SignatureDef(this);
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Tensorflow.TensorInfo>.Codec _map_inputs_codec
        = new pbc::MapField<string, global::Tensorflow.TensorInfo>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Tensorflow.TensorInfo.Parser), 10);
    private readonly pbc::MapField<string, global::Tensorflow.TensorInfo> inputs_ = new pbc::MapField<string, global::Tensorflow.TensorInfo>();
    /// <summary>
    /// Named input parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Tensorflow.TensorInfo> Inputs {
      get { return inputs_; }
    }

    /// <summary>Field number for the "outputs" field.</summary>
    public const int OutputsFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Tensorflow.TensorInfo>.Codec _map_outputs_codec
        = new pbc::MapField<string, global::Tensorflow.TensorInfo>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Tensorflow.TensorInfo.Parser), 18);
    private readonly pbc::MapField<string, global::Tensorflow.TensorInfo> outputs_ = new pbc::MapField<string, global::Tensorflow.TensorInfo>();
    /// <summary>
    /// Named output parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Tensorflow.TensorInfo> Outputs {
      get { return outputs_; }
    }

    /// <summary>Field number for the "method_name" field.</summary>
    public const int MethodNameFieldNumber = 3;
    private string methodName_ = "";
    /// <summary>
    /// Extensible method_name information enabling third-party users to mark a
    /// SignatureDef as supporting a particular method. This enables producers and
    /// consumers of SignatureDefs, e.g. a model definition library and a serving
    /// library to have a clear hand-off regarding the semantics of a computation.
    ///
    /// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
    /// method_name. This is commonly used to support multi-headed computation,
    /// where a single graph computation may return multiple results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MethodName {
      get { return methodName_; }
      set {
        methodName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignatureDef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignatureDef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Inputs.Equals(other.Inputs)) return false;
      if (!Outputs.Equals(other.Outputs)) return false;
      if (MethodName != other.MethodName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Inputs.GetHashCode();
      hash ^= Outputs.GetHashCode();
      if (MethodName.Length != 0) hash ^= MethodName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      inputs_.WriteTo(output, _map_inputs_codec);
      outputs_.WriteTo(output, _map_outputs_codec);
      if (MethodName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MethodName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += inputs_.CalculateSize(_map_inputs_codec);
      size += outputs_.CalculateSize(_map_outputs_codec);
      if (MethodName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MethodName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignatureDef other) {
      if (other == null) {
        return;
      }
      inputs_.Add(other.inputs_);
      outputs_.Add(other.outputs_);
      if (other.MethodName.Length != 0) {
        MethodName = other.MethodName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            inputs_.AddEntriesFrom(input, _map_inputs_codec);
            break;
          }
          case 18: {
            outputs_.AddEntriesFrom(input, _map_outputs_codec);
            break;
          }
          case 26: {
            MethodName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// An asset file def for a single file or a set of sharded files with the same
  /// name.
  /// </summary>
  public sealed partial class AssetFileDef : pb::IMessage<AssetFileDef> {
    private static readonly pb::MessageParser<AssetFileDef> _parser = new pb::MessageParser<AssetFileDef>(() => new AssetFileDef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AssetFileDef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.MetaGraphReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssetFileDef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssetFileDef(AssetFileDef other) : this() {
      tensorInfo_ = other.tensorInfo_ != null ? other.tensorInfo_.Clone() : null;
      filename_ = other.filename_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssetFileDef Clone() {
      return new AssetFileDef(this);
    }

    /// <summary>Field number for the "tensor_info" field.</summary>
    public const int TensorInfoFieldNumber = 1;
    private global::Tensorflow.TensorInfo tensorInfo_;
    /// <summary>
    /// The tensor to bind the asset filename to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.TensorInfo TensorInfo {
      get { return tensorInfo_; }
      set {
        tensorInfo_ = value;
      }
    }

    /// <summary>Field number for the "filename" field.</summary>
    public const int FilenameFieldNumber = 2;
    private string filename_ = "";
    /// <summary>
    /// The filename within an assets directory. Note: does not include the path
    /// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
    /// would be "vocab.txt".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Filename {
      get { return filename_; }
      set {
        filename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AssetFileDef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AssetFileDef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TensorInfo, other.TensorInfo)) return false;
      if (Filename != other.Filename) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tensorInfo_ != null) hash ^= TensorInfo.GetHashCode();
      if (Filename.Length != 0) hash ^= Filename.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (tensorInfo_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TensorInfo);
      }
      if (Filename.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Filename);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tensorInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TensorInfo);
      }
      if (Filename.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filename);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AssetFileDef other) {
      if (other == null) {
        return;
      }
      if (other.tensorInfo_ != null) {
        if (tensorInfo_ == null) {
          tensorInfo_ = new global::Tensorflow.TensorInfo();
        }
        TensorInfo.MergeFrom(other.TensorInfo);
      }
      if (other.Filename.Length != 0) {
        Filename = other.Filename;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tensorInfo_ == null) {
              tensorInfo_ = new global::Tensorflow.TensorInfo();
            }
            input.ReadMessage(tensorInfo_);
            break;
          }
          case 18: {
            Filename = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
