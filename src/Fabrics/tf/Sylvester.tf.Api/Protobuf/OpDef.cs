// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/framework/op_def.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/framework/op_def.proto</summary>
  public static partial class OpDefReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/framework/op_def.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OpDefReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiZ0ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL29wX2RlZi5wcm90bxIKdGVu",
            "c29yZmxvdxoqdGVuc29yZmxvdy9jb3JlL2ZyYW1ld29yay9hdHRyX3ZhbHVl",
            "LnByb3RvGiV0ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL3R5cGVzLnByb3Rv",
            "IrgFCgVPcERlZhIMCgRuYW1lGAEgASgJEisKCWlucHV0X2FyZxgCIAMoCzIY",
            "LnRlbnNvcmZsb3cuT3BEZWYuQXJnRGVmEiwKCm91dHB1dF9hcmcYAyADKAsy",
            "GC50ZW5zb3JmbG93Lk9wRGVmLkFyZ0RlZhInCgRhdHRyGAQgAygLMhkudGVu",
            "c29yZmxvdy5PcERlZi5BdHRyRGVmEi4KC2RlcHJlY2F0aW9uGAggASgLMhku",
            "dGVuc29yZmxvdy5PcERlcHJlY2F0aW9uEg8KB3N1bW1hcnkYBSABKAkSEwoL",
            "ZGVzY3JpcHRpb24YBiABKAkSFgoOaXNfY29tbXV0YXRpdmUYEiABKAgSFAoM",
            "aXNfYWdncmVnYXRlGBAgASgIEhMKC2lzX3N0YXRlZnVsGBEgASgIEiIKGmFs",
            "bG93c191bmluaXRpYWxpemVkX2lucHV0GBMgASgIGp8BCgZBcmdEZWYSDAoE",
            "bmFtZRgBIAEoCRITCgtkZXNjcmlwdGlvbhgCIAEoCRIiCgR0eXBlGAMgASgO",
            "MhQudGVuc29yZmxvdy5EYXRhVHlwZRIRCgl0eXBlX2F0dHIYBCABKAkSEwoL",
            "bnVtYmVyX2F0dHIYBSABKAkSFgoOdHlwZV9saXN0X2F0dHIYBiABKAkSDgoG",
            "aXNfcmVmGBAgASgIGr0BCgdBdHRyRGVmEgwKBG5hbWUYASABKAkSDAoEdHlw",
            "ZRgCIAEoCRIsCg1kZWZhdWx0X3ZhbHVlGAMgASgLMhUudGVuc29yZmxvdy5B",
            "dHRyVmFsdWUSEwoLZGVzY3JpcHRpb24YBCABKAkSEwoLaGFzX21pbmltdW0Y",
            "BSABKAgSDwoHbWluaW11bRgGIAEoAxItCg5hbGxvd2VkX3ZhbHVlcxgHIAEo",
            "CzIVLnRlbnNvcmZsb3cuQXR0clZhbHVlIjUKDU9wRGVwcmVjYXRpb24SDwoH",
            "dmVyc2lvbhgBIAEoBRITCgtleHBsYW5hdGlvbhgCIAEoCSInCgZPcExpc3QS",
            "HQoCb3AYASADKAsyES50ZW5zb3JmbG93Lk9wRGVmQmsKGG9yZy50ZW5zb3Jm",
            "bG93LmZyYW1ld29ya0ILT3BEZWZQcm90b3NQAVo9Z2l0aHViLmNvbS90ZW5z",
            "b3JmbG93L3RlbnNvcmZsb3cvdGVuc29yZmxvdy9nby9jb3JlL2ZyYW1ld29y",
            "a/gBAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.AttrValueReflection.Descriptor, global::Tensorflow.TypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.OpDef), global::Tensorflow.OpDef.Parser, new[]{ "Name", "InputArg", "OutputArg", "Attr", "Deprecation", "Summary", "Description", "IsCommutative", "IsAggregate", "IsStateful", "AllowsUninitializedInput" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.OpDef.Types.ArgDef), global::Tensorflow.OpDef.Types.ArgDef.Parser, new[]{ "Name", "Description", "Type", "TypeAttr", "NumberAttr", "TypeListAttr", "IsRef" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.OpDef.Types.AttrDef), global::Tensorflow.OpDef.Types.AttrDef.Parser, new[]{ "Name", "Type", "DefaultValue", "Description", "HasMinimum", "Minimum", "AllowedValues" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.OpDeprecation), global::Tensorflow.OpDeprecation.Parser, new[]{ "Version", "Explanation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.OpList), global::Tensorflow.OpList.Parser, new[]{ "Op" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Defines an operation. A NodeDef in a GraphDef specifies an Op by
  /// using the "op" field which should match the name of a OpDef.
  /// LINT.IfChange
  /// </summary>
  public sealed partial class OpDef : pb::IMessage<OpDef> {
    private static readonly pb::MessageParser<OpDef> _parser = new pb::MessageParser<OpDef>(() => new OpDef());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpDef> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.OpDefReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDef() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDef(OpDef other) : this() {
      name_ = other.name_;
      inputArg_ = other.inputArg_.Clone();
      outputArg_ = other.outputArg_.Clone();
      attr_ = other.attr_.Clone();
      deprecation_ = other.deprecation_ != null ? other.deprecation_.Clone() : null;
      summary_ = other.summary_;
      description_ = other.description_;
      isCommutative_ = other.isCommutative_;
      isAggregate_ = other.isAggregate_;
      isStateful_ = other.isStateful_;
      allowsUninitializedInput_ = other.allowsUninitializedInput_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDef Clone() {
      return new OpDef(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Op names starting with an underscore are reserved for internal use.
    /// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input_arg" field.</summary>
    public const int InputArgFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Tensorflow.OpDef.Types.ArgDef> _repeated_inputArg_codec
        = pb::FieldCodec.ForMessage(18, global::Tensorflow.OpDef.Types.ArgDef.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef> inputArg_ = new pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef>();
    /// <summary>
    /// Description of the input(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef> InputArg {
      get { return inputArg_; }
    }

    /// <summary>Field number for the "output_arg" field.</summary>
    public const int OutputArgFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Tensorflow.OpDef.Types.ArgDef> _repeated_outputArg_codec
        = pb::FieldCodec.ForMessage(26, global::Tensorflow.OpDef.Types.ArgDef.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef> outputArg_ = new pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef>();
    /// <summary>
    /// Description of the output(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.OpDef.Types.ArgDef> OutputArg {
      get { return outputArg_; }
    }

    /// <summary>Field number for the "attr" field.</summary>
    public const int AttrFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Tensorflow.OpDef.Types.AttrDef> _repeated_attr_codec
        = pb::FieldCodec.ForMessage(34, global::Tensorflow.OpDef.Types.AttrDef.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.OpDef.Types.AttrDef> attr_ = new pbc::RepeatedField<global::Tensorflow.OpDef.Types.AttrDef>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.OpDef.Types.AttrDef> Attr {
      get { return attr_; }
    }

    /// <summary>Field number for the "deprecation" field.</summary>
    public const int DeprecationFieldNumber = 8;
    private global::Tensorflow.OpDeprecation deprecation_;
    /// <summary>
    /// Optional deprecation based on GraphDef versions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.OpDeprecation Deprecation {
      get { return deprecation_; }
      set {
        deprecation_ = value;
      }
    }

    /// <summary>Field number for the "summary" field.</summary>
    public const int SummaryFieldNumber = 5;
    private string summary_ = "";
    /// <summary>
    /// One-line human-readable description of what the Op does.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Summary {
      get { return summary_; }
      set {
        summary_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 6;
    private string description_ = "";
    /// <summary>
    /// Additional, longer human-readable description of what the Op does.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_commutative" field.</summary>
    public const int IsCommutativeFieldNumber = 18;
    private bool isCommutative_;
    /// <summary>
    /// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCommutative {
      get { return isCommutative_; }
      set {
        isCommutative_ = value;
      }
    }

    /// <summary>Field number for the "is_aggregate" field.</summary>
    public const int IsAggregateFieldNumber = 16;
    private bool isAggregate_;
    /// <summary>
    /// If is_aggregate is true, then this operation accepts N >= 2
    /// inputs and produces 1 output all of the same type.  Should be
    /// associative and commutative, and produce output with the same
    /// shape as the input.  The optimizer may replace an aggregate op
    /// taking input from multiple devices with a tree of aggregate ops
    /// that aggregate locally within each device (and possibly within
    /// groups of nearby devices) before communicating.
    /// TODO(josh11b): Implement that optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAggregate {
      get { return isAggregate_; }
      set {
        isAggregate_ = value;
      }
    }

    /// <summary>Field number for the "is_stateful" field.</summary>
    public const int IsStatefulFieldNumber = 17;
    private bool isStateful_;
    /// <summary>
    /// Ops are marked as stateful if their behavior depends on some state beyond
    /// their input tensors (e.g. variable reading op) or if they have
    /// a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
    /// must always produce the same output for the same input and have
    /// no side-effects.
    ///
    /// By default Ops may be moved between devices.  Stateful ops should
    /// either not be moved, or should only be moved if that state can also
    /// be moved (e.g. via some sort of save / restore).
    /// Stateful ops are guaranteed to never be optimized away by Common
    /// Subexpression Elimination (CSE).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsStateful {
      get { return isStateful_; }
      set {
        isStateful_ = value;
      }
    }

    /// <summary>Field number for the "allows_uninitialized_input" field.</summary>
    public const int AllowsUninitializedInputFieldNumber = 19;
    private bool allowsUninitializedInput_;
    /// <summary>
    /// By default, all inputs to an Op must be initialized Tensors.  Ops
    /// that may initialize tensors for the first time should set this
    /// field to true, to allow the Op to take an uninitialized Tensor as
    /// input.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowsUninitializedInput {
      get { return allowsUninitializedInput_; }
      set {
        allowsUninitializedInput_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpDef);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpDef other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!inputArg_.Equals(other.inputArg_)) return false;
      if(!outputArg_.Equals(other.outputArg_)) return false;
      if(!attr_.Equals(other.attr_)) return false;
      if (!object.Equals(Deprecation, other.Deprecation)) return false;
      if (Summary != other.Summary) return false;
      if (Description != other.Description) return false;
      if (IsCommutative != other.IsCommutative) return false;
      if (IsAggregate != other.IsAggregate) return false;
      if (IsStateful != other.IsStateful) return false;
      if (AllowsUninitializedInput != other.AllowsUninitializedInput) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= inputArg_.GetHashCode();
      hash ^= outputArg_.GetHashCode();
      hash ^= attr_.GetHashCode();
      if (deprecation_ != null) hash ^= Deprecation.GetHashCode();
      if (Summary.Length != 0) hash ^= Summary.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (IsCommutative != false) hash ^= IsCommutative.GetHashCode();
      if (IsAggregate != false) hash ^= IsAggregate.GetHashCode();
      if (IsStateful != false) hash ^= IsStateful.GetHashCode();
      if (AllowsUninitializedInput != false) hash ^= AllowsUninitializedInput.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      inputArg_.WriteTo(output, _repeated_inputArg_codec);
      outputArg_.WriteTo(output, _repeated_outputArg_codec);
      attr_.WriteTo(output, _repeated_attr_codec);
      if (Summary.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Summary);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Description);
      }
      if (deprecation_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Deprecation);
      }
      if (IsAggregate != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(IsAggregate);
      }
      if (IsStateful != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsStateful);
      }
      if (IsCommutative != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(IsCommutative);
      }
      if (AllowsUninitializedInput != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(AllowsUninitializedInput);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += inputArg_.CalculateSize(_repeated_inputArg_codec);
      size += outputArg_.CalculateSize(_repeated_outputArg_codec);
      size += attr_.CalculateSize(_repeated_attr_codec);
      if (deprecation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Deprecation);
      }
      if (Summary.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Summary);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (IsCommutative != false) {
        size += 2 + 1;
      }
      if (IsAggregate != false) {
        size += 2 + 1;
      }
      if (IsStateful != false) {
        size += 2 + 1;
      }
      if (AllowsUninitializedInput != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpDef other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      inputArg_.Add(other.inputArg_);
      outputArg_.Add(other.outputArg_);
      attr_.Add(other.attr_);
      if (other.deprecation_ != null) {
        if (deprecation_ == null) {
          deprecation_ = new global::Tensorflow.OpDeprecation();
        }
        Deprecation.MergeFrom(other.Deprecation);
      }
      if (other.Summary.Length != 0) {
        Summary = other.Summary;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.IsCommutative != false) {
        IsCommutative = other.IsCommutative;
      }
      if (other.IsAggregate != false) {
        IsAggregate = other.IsAggregate;
      }
      if (other.IsStateful != false) {
        IsStateful = other.IsStateful;
      }
      if (other.AllowsUninitializedInput != false) {
        AllowsUninitializedInput = other.AllowsUninitializedInput;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            inputArg_.AddEntriesFrom(input, _repeated_inputArg_codec);
            break;
          }
          case 26: {
            outputArg_.AddEntriesFrom(input, _repeated_outputArg_codec);
            break;
          }
          case 34: {
            attr_.AddEntriesFrom(input, _repeated_attr_codec);
            break;
          }
          case 42: {
            Summary = input.ReadString();
            break;
          }
          case 50: {
            Description = input.ReadString();
            break;
          }
          case 66: {
            if (deprecation_ == null) {
              deprecation_ = new global::Tensorflow.OpDeprecation();
            }
            input.ReadMessage(deprecation_);
            break;
          }
          case 128: {
            IsAggregate = input.ReadBool();
            break;
          }
          case 136: {
            IsStateful = input.ReadBool();
            break;
          }
          case 144: {
            IsCommutative = input.ReadBool();
            break;
          }
          case 152: {
            AllowsUninitializedInput = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the OpDef message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// For describing inputs and outputs.
      /// </summary>
      public sealed partial class ArgDef : pb::IMessage<ArgDef> {
        private static readonly pb::MessageParser<ArgDef> _parser = new pb::MessageParser<ArgDef>(() => new ArgDef());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ArgDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.OpDef.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ArgDef() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ArgDef(ArgDef other) : this() {
          name_ = other.name_;
          description_ = other.description_;
          type_ = other.type_;
          typeAttr_ = other.typeAttr_;
          numberAttr_ = other.numberAttr_;
          typeListAttr_ = other.typeListAttr_;
          isRef_ = other.isRef_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ArgDef Clone() {
          return new ArgDef(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "description" field.</summary>
        public const int DescriptionFieldNumber = 2;
        private string description_ = "";
        /// <summary>
        /// Human readable description.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Description {
          get { return description_; }
          set {
            description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 3;
        private global::Tensorflow.DataType type_ = 0;
        /// <summary>
        /// Describes the type of one or more tensors that are accepted/produced
        /// by this input/output arg.  The only legal combinations are:
        /// * For a single tensor: either the "type" field is set or the
        ///   "type_attr" field is set to the name of an attr with type "type".
        /// * For a sequence of tensors with the same type: the "number_attr"
        ///   field will be set to the name of an attr with type "int", and
        ///   either the "type" or "type_attr" field will be set as for
        ///   single tensors.
        /// * For a sequence of tensors, the "type_list_attr" field will be set
        ///   to the name of an attr with type "list(type)".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Tensorflow.DataType Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "type_attr" field.</summary>
        public const int TypeAttrFieldNumber = 4;
        private string typeAttr_ = "";
        /// <summary>
        /// if specified, attr must have type "type"
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TypeAttr {
          get { return typeAttr_; }
          set {
            typeAttr_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "number_attr" field.</summary>
        public const int NumberAttrFieldNumber = 5;
        private string numberAttr_ = "";
        /// <summary>
        /// if specified, attr must have type "int"
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string NumberAttr {
          get { return numberAttr_; }
          set {
            numberAttr_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type_list_attr" field.</summary>
        public const int TypeListAttrFieldNumber = 6;
        private string typeListAttr_ = "";
        /// <summary>
        /// If specified, attr must have type "list(type)", and none of
        /// type, type_attr, and number_attr may be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TypeListAttr {
          get { return typeListAttr_; }
          set {
            typeListAttr_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "is_ref" field.</summary>
        public const int IsRefFieldNumber = 16;
        private bool isRef_;
        /// <summary>
        /// For inputs: if true, the inputs are required to be refs.
        ///   By default, inputs can be either refs or non-refs.
        /// For outputs: if true, outputs are refs, otherwise they are not.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsRef {
          get { return isRef_; }
          set {
            isRef_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ArgDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ArgDef other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Description != other.Description) return false;
          if (Type != other.Type) return false;
          if (TypeAttr != other.TypeAttr) return false;
          if (NumberAttr != other.NumberAttr) return false;
          if (TypeListAttr != other.TypeListAttr) return false;
          if (IsRef != other.IsRef) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Description.Length != 0) hash ^= Description.GetHashCode();
          if (Type != 0) hash ^= Type.GetHashCode();
          if (TypeAttr.Length != 0) hash ^= TypeAttr.GetHashCode();
          if (NumberAttr.Length != 0) hash ^= NumberAttr.GetHashCode();
          if (TypeListAttr.Length != 0) hash ^= TypeListAttr.GetHashCode();
          if (IsRef != false) hash ^= IsRef.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Description.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Description);
          }
          if (Type != 0) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Type);
          }
          if (TypeAttr.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(TypeAttr);
          }
          if (NumberAttr.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(NumberAttr);
          }
          if (TypeListAttr.Length != 0) {
            output.WriteRawTag(50);
            output.WriteString(TypeListAttr);
          }
          if (IsRef != false) {
            output.WriteRawTag(128, 1);
            output.WriteBool(IsRef);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Description.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
          }
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (TypeAttr.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TypeAttr);
          }
          if (NumberAttr.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(NumberAttr);
          }
          if (TypeListAttr.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TypeListAttr);
          }
          if (IsRef != false) {
            size += 2 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ArgDef other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Description.Length != 0) {
            Description = other.Description;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
          if (other.TypeAttr.Length != 0) {
            TypeAttr = other.TypeAttr;
          }
          if (other.NumberAttr.Length != 0) {
            NumberAttr = other.NumberAttr;
          }
          if (other.TypeListAttr.Length != 0) {
            TypeListAttr = other.TypeListAttr;
          }
          if (other.IsRef != false) {
            IsRef = other.IsRef;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Description = input.ReadString();
                break;
              }
              case 24: {
                type_ = (global::Tensorflow.DataType) input.ReadEnum();
                break;
              }
              case 34: {
                TypeAttr = input.ReadString();
                break;
              }
              case 42: {
                NumberAttr = input.ReadString();
                break;
              }
              case 50: {
                TypeListAttr = input.ReadString();
                break;
              }
              case 128: {
                IsRef = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Description of the graph-construction-time configuration of this
      /// Op.  That is to say, this describes the attr fields that will
      /// be specified in the NodeDef.
      /// </summary>
      public sealed partial class AttrDef : pb::IMessage<AttrDef> {
        private static readonly pb::MessageParser<AttrDef> _parser = new pb::MessageParser<AttrDef>(() => new AttrDef());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AttrDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.OpDef.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AttrDef() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AttrDef(AttrDef other) : this() {
          name_ = other.name_;
          type_ = other.type_;
          defaultValue_ = other.defaultValue_ != null ? other.defaultValue_.Clone() : null;
          description_ = other.description_;
          hasMinimum_ = other.hasMinimum_;
          minimum_ = other.minimum_;
          allowedValues_ = other.allowedValues_ != null ? other.allowedValues_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AttrDef Clone() {
          return new AttrDef(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// A descriptive name for the argument.  May be used, e.g. by the
        /// Python client, as a keyword argument name, and so should match
        /// the regexp "[a-z][a-z0-9_]+".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private string type_ = "";
        /// <summary>
        /// One of the type names from attr_value.proto ("string", "list(string)",
        /// "int", etc.).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type {
          get { return type_; }
          set {
            type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "default_value" field.</summary>
        public const int DefaultValueFieldNumber = 3;
        private global::Tensorflow.AttrValue defaultValue_;
        /// <summary>
        /// A reasonable default for this attribute if the user does not supply
        /// a value.  If not specified, the user must supply a value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Tensorflow.AttrValue DefaultValue {
          get { return defaultValue_; }
          set {
            defaultValue_ = value;
          }
        }

        /// <summary>Field number for the "description" field.</summary>
        public const int DescriptionFieldNumber = 4;
        private string description_ = "";
        /// <summary>
        /// Human-readable description.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Description {
          get { return description_; }
          set {
            description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "has_minimum" field.</summary>
        public const int HasMinimumFieldNumber = 5;
        private bool hasMinimum_;
        /// <summary>
        /// For type == "int", this is a minimum value.  For "list(___)"
        /// types, this is the minimum length.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMinimum {
          get { return hasMinimum_; }
          set {
            hasMinimum_ = value;
          }
        }

        /// <summary>Field number for the "minimum" field.</summary>
        public const int MinimumFieldNumber = 6;
        private long minimum_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Minimum {
          get { return minimum_; }
          set {
            minimum_ = value;
          }
        }

        /// <summary>Field number for the "allowed_values" field.</summary>
        public const int AllowedValuesFieldNumber = 7;
        private global::Tensorflow.AttrValue allowedValues_;
        /// <summary>
        /// The set of allowed values.  Has type that is the "list" version
        /// of the "type" field above (uses the "list" field of AttrValue).
        /// If type == "type" or "list(type)" above, then the "type" field
        /// of "allowed_values.list" has the set of allowed DataTypes.
        /// If type == "string" or "list(string)", then the "s" field of
        /// "allowed_values.list" has the set of allowed strings.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Tensorflow.AttrValue AllowedValues {
          get { return allowedValues_; }
          set {
            allowedValues_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AttrDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AttrDef other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Type != other.Type) return false;
          if (!object.Equals(DefaultValue, other.DefaultValue)) return false;
          if (Description != other.Description) return false;
          if (HasMinimum != other.HasMinimum) return false;
          if (Minimum != other.Minimum) return false;
          if (!object.Equals(AllowedValues, other.AllowedValues)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Type.Length != 0) hash ^= Type.GetHashCode();
          if (defaultValue_ != null) hash ^= DefaultValue.GetHashCode();
          if (Description.Length != 0) hash ^= Description.GetHashCode();
          if (HasMinimum != false) hash ^= HasMinimum.GetHashCode();
          if (Minimum != 0L) hash ^= Minimum.GetHashCode();
          if (allowedValues_ != null) hash ^= AllowedValues.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Type.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Type);
          }
          if (defaultValue_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(DefaultValue);
          }
          if (Description.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(Description);
          }
          if (HasMinimum != false) {
            output.WriteRawTag(40);
            output.WriteBool(HasMinimum);
          }
          if (Minimum != 0L) {
            output.WriteRawTag(48);
            output.WriteInt64(Minimum);
          }
          if (allowedValues_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(AllowedValues);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Type.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
          }
          if (defaultValue_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultValue);
          }
          if (Description.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
          }
          if (HasMinimum != false) {
            size += 1 + 1;
          }
          if (Minimum != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Minimum);
          }
          if (allowedValues_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedValues);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AttrDef other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Type.Length != 0) {
            Type = other.Type;
          }
          if (other.defaultValue_ != null) {
            if (defaultValue_ == null) {
              defaultValue_ = new global::Tensorflow.AttrValue();
            }
            DefaultValue.MergeFrom(other.DefaultValue);
          }
          if (other.Description.Length != 0) {
            Description = other.Description;
          }
          if (other.HasMinimum != false) {
            HasMinimum = other.HasMinimum;
          }
          if (other.Minimum != 0L) {
            Minimum = other.Minimum;
          }
          if (other.allowedValues_ != null) {
            if (allowedValues_ == null) {
              allowedValues_ = new global::Tensorflow.AttrValue();
            }
            AllowedValues.MergeFrom(other.AllowedValues);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Type = input.ReadString();
                break;
              }
              case 26: {
                if (defaultValue_ == null) {
                  defaultValue_ = new global::Tensorflow.AttrValue();
                }
                input.ReadMessage(defaultValue_);
                break;
              }
              case 34: {
                Description = input.ReadString();
                break;
              }
              case 40: {
                HasMinimum = input.ReadBool();
                break;
              }
              case 48: {
                Minimum = input.ReadInt64();
                break;
              }
              case 58: {
                if (allowedValues_ == null) {
                  allowedValues_ = new global::Tensorflow.AttrValue();
                }
                input.ReadMessage(allowedValues_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about version-dependent deprecation of an op
  /// </summary>
  public sealed partial class OpDeprecation : pb::IMessage<OpDeprecation> {
    private static readonly pb::MessageParser<OpDeprecation> _parser = new pb::MessageParser<OpDeprecation>(() => new OpDeprecation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpDeprecation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.OpDefReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDeprecation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDeprecation(OpDeprecation other) : this() {
      version_ = other.version_;
      explanation_ = other.explanation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpDeprecation Clone() {
      return new OpDeprecation(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private int version_;
    /// <summary>
    /// First GraphDef version at which the op is disallowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "explanation" field.</summary>
    public const int ExplanationFieldNumber = 2;
    private string explanation_ = "";
    /// <summary>
    /// Explanation of why it was deprecated and what to use instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Explanation {
      get { return explanation_; }
      set {
        explanation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpDeprecation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpDeprecation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (Explanation != other.Explanation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version != 0) hash ^= Version.GetHashCode();
      if (Explanation.Length != 0) hash ^= Explanation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Version);
      }
      if (Explanation.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Explanation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      if (Explanation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Explanation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpDeprecation other) {
      if (other == null) {
        return;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
      if (other.Explanation.Length != 0) {
        Explanation = other.Explanation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = input.ReadInt32();
            break;
          }
          case 18: {
            Explanation = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A collection of OpDefs
  /// </summary>
  public sealed partial class OpList : pb::IMessage<OpList> {
    private static readonly pb::MessageParser<OpList> _parser = new pb::MessageParser<OpList>(() => new OpList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.OpDefReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpList(OpList other) : this() {
      op_ = other.op_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpList Clone() {
      return new OpList(this);
    }

    /// <summary>Field number for the "op" field.</summary>
    public const int OpFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Tensorflow.OpDef> _repeated_op_codec
        = pb::FieldCodec.ForMessage(10, global::Tensorflow.OpDef.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.OpDef> op_ = new pbc::RepeatedField<global::Tensorflow.OpDef>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.OpDef> Op {
      get { return op_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!op_.Equals(other.op_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= op_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      op_.WriteTo(output, _repeated_op_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += op_.CalculateSize(_repeated_op_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpList other) {
      if (other == null) {
        return;
      }
      op_.Add(other.op_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            op_.AddEntriesFrom(input, _repeated_op_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
